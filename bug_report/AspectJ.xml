<bugrepository name="AspectJ"><bug commit="044542c" fixdate="1161270000" id="161217" opendate="1161090000" status="resolved fixed"><buginformation><summary>161217 NPE in BcelAdvice</summary><description>I've been playing with some aspect deployment models and got into this error during project rebuild from AJDT: java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:199) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:699) at org.aspectj.weaver.Shadow.implement(Shadow.java:471) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2832) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:506) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeave ... lasses when weaving when batch building BuildConfig[...] #Files=6 Here is the aspect and classes it is applied to: ----- @Aspect("percflow(execution(* InstrumentedBean.getProperty2()))") public class GetFieldAtAspect { @Around("execution(* ConfigurableBean.getProperty2())") public Object onGet(ProceedingJoinPoint jp) throws Throwable { return jp.proceed(); } } ------ import org.springframework.beans.factory.InitializingBean; public class InstrumentedBean implements InitializingBean, IInstrumentedBean { private ConfigurableBean configurableBean; private String value; private transient String transientValue = "aaa"; public void afterPropertiesSet() throws Exception { this.configurableBean = new ConfigurableBean(); } public String getProperty1() { synchronized(this) { return this.configurableBean.getProperty1(); } } public String getProperty2() { synchronized(this) { return this.configurableBean.getProperty2(); } } public void setValue(String value) { synchronized(this) { this.value = value; } } public Object getValue() { synchronized(this) { return value; } } public Object getTransientValue() { return transientValue; } public void setTransientValue(String transientValue) { this.transientValue = transientValue; } } ------ import java.io.Serializable; import org.springframework.beans.factory.annotation.Configurable; @Configurable public class ConfigurableBean implements Serializable { private static final long serialVersionUID = 1L; private String property1; private String property2; public ConfigurableBean() { } public String getProperty1() { return this.property1; } public String getProperty2() { return this.property2; } public void setProperty1(String property1) { this.property1 = property1; } public void setProperty2(String property2) { this.property2 = property2; } }</description></buginformation><fixedFiles><file>tests/bugs153/pr161217/AtAspectJAspect.java</file><file>tests/bugs153/pr161217/C.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file></fixedFiles></bug><bug commit="d532892" fixdate="1160150000" id="159896" opendate="1160060000" status="resolved fixed"><buginformation><summary>159896 advice from injars do not have unique handles with the JDTLikeHandleProvider</summary><description>Advice of the same kind contained in the same aspect currently do not have unique handles if the aspect is on the aspectpath.</description></buginformation><fixedFiles><file>tests/features153/jdtlikehandleprovider/ClassForAspectpath.java</file><file>tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java</file><file>weaver/src/org/aspectj/weaver/ShadowMunger.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java</file></fixedFiles></bug><bug commit="782ade2" fixdate="1159890000" id="156904" opendate="1158000000" status="resolved fixed"><buginformation><summary>156904 Incorrect warning when advising a private method of a private inner class</summary><description>The Eclipse AJDT give an incorrect warning when you want to advise a private method of a private inner class. When I want to advise a private method in a private inner class, like this public class Outer { private class Inner { private void myMethod() } } Using the following poincut: poincut innerpointcut():execution( * Outer.Inner.myMethod() ); and advice: before():innerpointcut() { System.out.println( "executing!" ); } I get a warning "invalidAbsoluteTypeName" next to my pointcut, but next to the advice, there is a marker that points to the private method.</description></buginformation><fixedFiles><file>tests/bugs153/pr156904/inDiffPkgAndImport/Outer.java</file><file>tests/bugs153/pr156904/inDiffPkgWithoutImport/Outer.java</file><file>tests/bugs153/pr156904/inSamePkg/Outer.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file></fixedFiles></bug><bug commit="7b831ff" fixdate="1159890000" id="152366" opendate="1154370000" status="resolved fixed"><buginformation><summary>152366 LTW Within Patterns Should Accept AND For Consistency</summary><description>The load-time weaving definition system accepts AND in addition to &amp;&amp; for pointcuts, but it silently accepts and then fails to work with type patterns that use AND. Such type patterns are important when creating exceptions (e.g., excluding weblogic..* &amp;&amp; !weblogic.jdbc..*) and using AND is also helpful here. I've attached a patch to support this and tests to show it's working.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java</file></fixedFiles></bug><bug commit="cd9fd11" fixdate="1159540000" id="158573" opendate="1159200000" status="resolved fixed"><buginformation><summary>158573 changing value of variable in aspect results in adviceDidNotMatch warning</summary><description /></buginformation><fixedFiles><file>tests/multiIncremental/PR158573/base/C.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembers.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file></fixedFiles></bug><bug commit="ea4ff8a" fixdate="1159530000" id="158624" opendate="1159210000" status="resolved fixed"><buginformation><summary>158624 Compiler Error: generics and arrays</summary><description>OK, not sure what to report here or what info you need, but here's the set up, message, and erroreous class. I don't understand the errors from the compiler enough to parse down the erroneous file to something that contains only the bug, but I could if direction were given. Here's my set up: Eclipse SDK Version: 3.2.0 Build id: M20060629-1905 With AJDT: Eclipse AspectJ Development Tools Version: 1.4.1.200608141223 AspectJ version: 1.5.3.200608210848 Here's the bug dump from the compiler inside Eclipse: java.lang.UnsupportedOperationException at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:221) at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:680) at org.aspectj.weaver.ResolvedMemberImpl.parameterize(ResolvedMemberImpl.java:690) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:643) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597) at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508) at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:226) at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118) at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171) at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128) at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:346) at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:327) at org.aspectj.weaver.World.resolve(World.java:523) at org.aspectj.weaver.MemberImpl.resolve(MemberImpl.java:93) at org.aspectj.weaver.JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember(JoinPointSignatureIterator.java:109) at org.aspectj.weaver.JoinPointSignatureIterator.&lt;init&gt;(JoinPointSignatureIterator.java:51) at org.aspectj.weaver.MemberImpl.getJoinPointSignatures(MemberImpl.java:943) at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:286) at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:106) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146) at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:146) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:75) at org.aspectj.weaver.Advice.match(Advice.java:112) at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:117) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2806) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInvokeInstruction(BcelClassWeaver.java:2768) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2506) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2332) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:494) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1606) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1557) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1335) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1155) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:455) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:392) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:380) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:892) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in: public class com.wec.lib.util.test.SyncValueTest extends junit.framework.TestCase: private com.wec.lib.util.test.SyncValueTest$SyncInteger a private com.wec.lib.util.test.SyncValueTest$SyncInteger b private com.wec.lib.util.test.SyncValueTest$SyncInteger c private com.wec.lib.util.test.SyncValueTest$SyncInteger d private com.wec.lib.util.test.SyncValueTest$SyncInteger e public void &lt;init&gt;(): ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 17) INVOKESPECIAL junit.framework.TestCase.&lt;init&gt; ()V constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;()) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 27) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_1 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 28) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_2 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 29) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_3 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 30) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_4 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 31) | NEW com.wec.lib.util.test.SyncValueTest$SyncInteger | DUP | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | ICONST_5 | INVOKESPECIAL com.wec.lib.util.test.SyncValueTest$SyncInteger.&lt;init&gt; (Lcom/wec/lib/util/test/SyncValueTest;I)V | PUTFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | RETURN (line 17) constructor-execution(void com.wec.lib.util.test.SyncValueTest.&lt;init&gt;()) end public void &lt;init&gt;() public void testSyncValueGroup() org.aspectj.weaver.MethodDeclarationLineNumber: 39:1035 : method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup()) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 42) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[])) | | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | method-call(void com.wec.lib.util.test.SyncValueTest$SyncInteger.link(com.wec.lib.util.SyncValueGroup[])) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 43) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | IF_ACMPNE L0 | ICONST_1 | GOTO L1 | L0: ICONST_0 | L1: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 44) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L2 | ICONST_1 | GOTO L3 | L2: ICONST_0 | L3: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 45) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_2 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_2 (line 46) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L4 | ICONST_1 | GOTO L5 | L4: ICONST_0 | L5: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 47) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ICONST_2 (line 48) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L6 | ICONST_1 | GOTO L7 | L6: ICONST_0 | L7: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 49) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_3 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_3 (line 50) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L8 | ICONST_1 | GOTO L9 | L8: ICONST_0 | L9: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 51) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L10 | ICONST_1 | GOTO L11 | L10: ICONST_0 | L11: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 52) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_4 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_4 (line 53) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L12 | ICONST_1 | GOTO L13 | L12: ICONST_0 | L13: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_4 (line 54) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L14 | ICONST_1 | GOTO L15 | L14: ICONST_0 | L15: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 55) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_1 (line 56) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L16 | ICONST_1 | GOTO L17 | L16: ICONST_0 | L17: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 57) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L18 | ICONST_1 | GOTO L19 | L18: ICONST_0 | L19: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 59) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 60) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | IF_ACMPNE L20 | ICONST_1 | GOTO L21 | L20: ICONST_0 | L21: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 63) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ICONST_1 (line 64) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L22 | ICONST_1 | GOTO L23 | L22: ICONST_0 | L23: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 65) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L24 | ICONST_1 | GOTO L25 | L24: ICONST_0 | L25: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 66) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | BIPUSH 8 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | BIPUSH 8 (line 67) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L26 | ICONST_1 | GOTO L27 | L26: ICONST_0 | L27: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 68) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L28 | ICONST_1 | GOTO L29 | L28: ICONST_0 | L29: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 69) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L30 | ICONST_1 | GOTO L31 | L30: ICONST_0 | L31: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 70) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L32 | ICONST_1 | GOTO L33 | L32: ICONST_0 | L33: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | BIPUSH 8 (line 71) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L34 | ICONST_1 | GOTO L35 | L34: ICONST_0 | L35: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 74) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 75) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_3 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 76) | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_2 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_2 (line 77) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L36 | ICONST_1 | GOTO L37 | L36: ICONST_0 | L37: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 78) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L38 | ICONST_1 | GOTO L39 | L38: ICONST_0 | L39: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 79) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L40 | ICONST_1 | GOTO L41 | L40: ICONST_0 | L41: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 80) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L42 | ICONST_1 | GOTO L43 | L42: ICONST_0 | L43: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_2 (line 81) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L44 | ICONST_1 | GOTO L45 | L44: ICONST_0 | L45: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 82) | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.unlink ()V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 83) | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | ANEWARRAY com.wec.lib.util.SyncValueGroup | DUP | ICONST_0 | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | AASTORE | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.link ([Lcom/wec/lib/util/SyncValueGroup;)V | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this (line 84) | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | ICONST_1 | INVOKESTATIC java.lang.Integer.valueOf (I)Ljava/lang/Integer; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.setValue (Ljava/lang/Object;)V | ICONST_1 (line 85) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.a Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L46 | ICONST_1 | GOTO L47 | L46: ICONST_0 | L47: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 86) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.b Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L48 | ICONST_1 | GOTO L49 | L48: ICONST_0 | L49: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 87) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.c Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L50 | ICONST_1 | GOTO L51 | L50: ICONST_0 | L51: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_3 (line 88) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.d Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L52 | ICONST_1 | GOTO L53 | L52: ICONST_0 | L53: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | ICONST_1 (line 89) | ALOAD_0 // Lcom/wec/lib/util/test/SyncValueTest; this | GETFIELD com.wec.lib.util.test.SyncValueTest.e Lcom/wec/lib/util/test/SyncValueTest$SyncInteger; | INVOKEVIRTUAL com.wec.lib.util.test.SyncValueTest$SyncInteger.getValue ()Ljava/lang/Object; | CHECKCAST java.lang.Integer | INVOKEVIRTUAL java.lang.Integer.intValue ()I | IF_ICMPNE L54 | ICONST_1 | GOTO L55 | L54: ICONST_0 | L55: INVOKESTATIC com.wec.lib.util.test.SyncValueTest.assertTrue (Z)V | RETURN (line 90) method-execution(void com.wec.lib.util.test.SyncValueTest.testSyncValueGroup()) end public void testSyncValueGroup() end public class com.wec.lib.util.test.SyncValueTest when weaving classes when weaving when batch building BuildConfig[D:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\ANSER2.generated.lst] #Files=365 Here's the class: package com.wec.lib.util.test; import static com.wec.ide.Constants.UNCHECKED; import junit.framework.TestCase; import org.junit.Test; import com.wec.lib.util.SyncValueGroup; import com.wec.scrum.Tests; /** * This class tests the SyncValueGroup utility class. */ @Tests(classes = { SyncValueGroup.class }) @SuppressWarnings("nls") public class SyncValueTest extends TestCase { class SyncInteger extends SyncValueGroup&lt;Integer&gt; { public SyncInteger(int val) { super(new Integer(val)); } public void valueChanged() { } } private SyncInteger a = new SyncInteger(1); private SyncInteger b = new SyncInteger(2); private SyncInteger c = new SyncInteger(3); private SyncInteger d = new SyncInteger(4); private SyncInteger e = new SyncInteger(5); /** * Ensures that SyncValueGroup replicates values and * calls valueChange. */ @SuppressWarnings(UNCHECKED) @Test public void testSyncValueGroup() { // Link tests a.link(b); assertTrue(a.getValue() == b.getValue()); assertTrue(1 == b.getValue()); b.setValue(2); assertTrue(2 == a.getValue()); b.link(c); assertTrue(2 == c.getValue()); c.setValue(3); assertTrue(3 == a.getValue()); assertTrue(3 == b.getValue()); a.setValue(4); assertTrue(4 == c.getValue()); assertTrue(4 == b.getValue()); b.setValue(1); assertTrue(1 == c.getValue()); assertTrue(1 == a.getValue()); d.link(e); assertTrue(d.getValue() == e.getValue()); // Join loops b.link(d); assertTrue(1 == d.getValue()); assertTrue(1 == e.getValue()); d.setValue(8); assertTrue(8 == a.getValue()); assertTrue(8 == b.getValue()); assertTrue(8 == c.getValue()); assertTrue(8 == d.getValue()); assertTrue(8 == e.getValue()); // Unlink tests c.unlink(); c.setValue(3); b.setValue(2); assertTrue(2 == a.getValue()); assertTrue(2 == b.getValue()); assertTrue(3 == c.getValue()); assertTrue(2 == d.getValue()); assertTrue(2 == e.getValue()); d.unlink(); c.link(d); a.setValue(1); assertTrue(1 == a.getValue()); assertTrue(1 == b.getValue()); assertTrue(3 == c.getValue()); assertTrue(3 == d.getValue()); assertTrue(1 == e.getValue()); } }</description></buginformation><fixedFiles><file>tests/bugs153/pr158624/ValueChange.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java</file></fixedFiles></bug><bug commit="fc39df1" fixdate="1159260000" id="148908" opendate="1151450000" status="resolved fixed"><buginformation><summary>148908 incorrect source signature for field ipe with qualified allocation expression</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file><file>tests/bugs153/pr148908/BadInterface.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file></fixedFiles></bug><bug commit="e56a69a" fixdate="1159190000" id="158412" opendate="1159000000" status="resolved fixed"><buginformation><summary>158412 @Pointcut in declare error results in NPE</summary><description>I am trying to use an @AspectJ @Pointcut in a "normal" AspectJ declare error expression. That results in the following exception. java.lang.NullPointerException at org.aspectj.weaver.patterns.ReferencePointcut.concretize1(ReferencePointcut.java:361) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.NotPointcut.concretize1(NotPointcut.java:100) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.AndPointcut.concretize1(AndPointcut.java:97) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:233) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:220) at org.aspectj.weaver.Checker.concretize(Checker.java:45) at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger(CrosscuttingMembers.java:91) at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers.java:122) at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers.java:113) at org.aspectj.weaver.CrosscuttingMembersSet.addAdviceLikeDeclares(CrosscuttingMembersSet.java:117) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addAdviceLikeDeclares(AjLookupEnvironment.java:382) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:245) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:887) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:244) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java</file><file>tests/bugs153/pr158412/dao/Foo.java</file><file>tests/bugs153/pr158412/layering/SystemArchitektur.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file></fixedFiles></bug><bug commit="70ae0f8" fixdate="1158230000" id="153845" opendate="1155610000" status="resolved fixed"><buginformation><summary>153845 [generics] Problem with signature for generic type</summary><description>public aspect OuterAspect { private pointcut isSetter() : execution(void set*(..)); public static aspect InnerAspect pertarget(isSetter()) { } } java.lang.IllegalStateException at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseFieldTypeSignature(GenericSignatureParser.java:163) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseTypeArgument(GenericSignatureParser.java:253) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.maybeParseTypeArguments(GenericSignatureParser.java:261) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseClassTypeSignature(GenericSignatureParser.java:208) at org.aspectj.apache.bcel.classfile.GenericSignatureParser.parseAsClassSignature(GenericSignatureParser.java:56) at org.aspectj.apache.bcel.classfile.Signature.asClassSignature(Signature.java:315) at org.aspectj.apache.bcel.classfile.JavaClass.getGenericClassTypeSignature(JavaClass.java:973) at org.aspectj.weaver.bcel.BcelObjectType.initializeFromJavaclass(BcelObjectType.java:164) at org.aspectj.weaver.bcel.BcelObjectType.&lt;init&gt;(BcelObjectType.java:131) at org.aspectj.weaver.bcel.BcelWorld.buildBcelDelegate(BcelWorld.java:337) at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:395) at org.aspectj.weaver.bcel.BcelWeaver.addIfAspect(BcelWeaver.java:263) at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromDirectory(BcelWeaver.java:255) at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:205) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:698) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:223) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:199) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) IllegalStateException thrown: Expecting [,L, or T, but found Pjava while unpacking Ljava/util/AbstractSet&lt;Pjava/util/Map$Entry&lt;TK;TV;&gt;;&gt;;</description></buginformation><fixedFiles><file>tests/bugs153/pr153845/Aspect.java</file><file>tests/bugs153/pr153845/Aspect2.java</file><file>tests/bugs153/pr153845/GenericType.java</file><file>tests/bugs153/pr153845/Interface.java</file><file>tests/bugs153/pr153845/Nothing.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/ReferenceType.java</file></fixedFiles></bug><bug commit="090de7e" fixdate="1157380000" id="155972" opendate="1157110000" status="resolved fixed"><buginformation><summary>155972 NullPointerException in ConstructorSignature.getConstructor()</summary><description>AspectJ version: 1.5.3.200608290814 When advising a constructor, we can do the following to obtain the constructor as a java.lang.reflect.Member: Member cons = ((ConstructorSignature) thisJoinPointStaticPart .getSignature()).getConstructor(); however that sometimes fails, and returns null.</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java</file><file>tests/bugs153/pr155972/ConstructorTest.java</file><file>tests/bugs153/pr155972/FieldTest.java</file><file>tests/bugs153/pr155972/InitializerTest.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file></fixedFiles></bug><bug commit="14e8b7d" fixdate="1156930000" id="155238" opendate="1156520000" status="resolved fixed"><buginformation><summary>155238 Trace should use System.identityHashCode, not hashCode</summary><description>The tracing module uses obj.hashCode() to identify untrusted objects when formatting. I think it would be a little safer and more accurate to use System.identityHashCode(obj). This way the tracing code wouldn't call any application-defined code, and would give a value that can't change if the loader state changes.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java</file><file>weaver/src/org/aspectj/weaver/tools/AbstractTrace.java</file></fixedFiles></bug><bug commit="6be7097" fixdate="1156520000" id="155148" opendate="1156470000" status="resolved fixed"><buginformation><summary>155148 jdk14 trace deadlock in oc4j</summary><description>I turned on tracing for the Aj class inside of Oracle's OC4J server. In one test (not always) it deadlocked. It looks like the threads are each trying to lock each other's loader. Notice that one of the threads is in the toString method of the Oracle ClassLoader (perhaps another reason to prefer tracing argument class names and system identity hashcodes). Here's a thread dump from Ctrl+BREAK: Found one Java-level deadlock: ============================= "WorkExecutorWorkerThread-1": waiting to lock monitor 0x003384ec (object 0x05239e48, a oracle.classloader.Po licyClassLoader), which is held by "OC4J Launcher" "OC4J Launcher": waiting to lock monitor 0x0033848c (object 0x0554f0e8, a oracle.classloader.Po licyClassLoader), which is held by "WorkExecutorWorkerThread-1" Java stack information for the threads listed above: =================================================== "WorkExecutorWorkerThread-1": at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:641) - waiting to lock &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa der.java:1284) at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java: 69) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.SearchPolicy.loadClass(SearchPolicy.java:642) - locked &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.askParentForClass(PolicyClassLoa der.java:1284) at oracle.classloader.SearchPolicy$AskParent.getClass(SearchPolicy.java: 69) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa der.java:1660) - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1621) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1606) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) - locked &lt;0x056a9ed0&gt; (a oracle.classloader.PolicyClassLoader) at oracle.j2ee.ra.jms.generic.WorkConsumer.doReceive(WorkConsumer.java:9 87) at oracle.j2ee.ra.jms.generic.WorkConsumer.run(WorkConsumer.java:215) - locked &lt;0x05de2718&gt; (a oracle.j2ee.ra.jms.generic.WorkConsumer) at oracle.j2ee.connector.work.WorkWrapper.runTargetWork(WorkWrapper.java :242) at oracle.j2ee.connector.work.WorkWrapper.doWork(WorkWrapper.java:215) at oracle.j2ee.connector.work.WorkWrapper.run(WorkWrapper.java:190) at EDU.oswego.cs.dl.util.concurrent.PooledExecutor$Worker.run(PooledExec utor.java:814) at java.lang.Thread.run(Thread.java:595) "OC4J Launcher": at oracle.classloader.PolicyClassLoader.toString(PolicyClassLoader.java: 1846) - waiting to lock &lt;0x0554f0e8&gt; (a oracle.classloader.PolicyClassLoader) at java.text.MessageFormat.subformat(MessageFormat.java:1237) at java.text.MessageFormat.format(MessageFormat.java:828) at java.text.Format.format(Format.java:133) at java.text.MessageFormat.format(MessageFormat.java:804) at java.util.logging.Formatter.formatMessage(Formatter.java:130) - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter) at java.util.logging.SimpleFormatter.format(SimpleFormatter.java:63) - locked &lt;0x0514e920&gt; (a java.util.logging.SimpleFormatter) at java.util.logging.StreamHandler.publish(StreamHandler.java:179) - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler) at java.util.logging.FileHandler.publish(FileHandler.java:555) - locked &lt;0x0514a0a8&gt; (a java.util.logging.FileHandler) at java.util.logging.Logger.log(Logger.java:428) at java.util.logging.Logger.doLog(Logger.java:450) at java.util.logging.Logger.logp(Logger.java:619) at java.util.logging.Logger.entering(Logger.java:870) at org.aspectj.weaver.tools.Jdk14Trace.enter(Jdk14Trace.java:32) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:67) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(C lassPreProcessorAgentAdapter.java:55) at sun.instrument.TransformerManager.transform(TransformerManager.java:1 22) at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java :155) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at oracle.classloader.PolicyClassLoader.defineClass(PolicyClassLoader.ja va:2224) at oracle.classloader.PolicyClassLoader.findLocalClass(PolicyClassLoader .java:1457) at oracle.classloader.SearchPolicy$FindLocal.getClass(SearchPolicy.java: 167) at oracle.classloader.SearchSequence.getClass(SearchSequence.java:119) at oracle.classloader.PolicyClassLoader.internalLoadClass(PolicyClassLoa der.java:1660) - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1621) at oracle.classloader.PolicyClassLoader.loadClass(PolicyClassLoader.java :1606) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) - locked &lt;0x05239e48&gt; (a oracle.classloader.PolicyClassLoader) at com.evermind.server.http.HttpRequestHandler.&lt;init&gt;(HttpRequestHandler .java:97) at com.evermind.server.http.HttpConnectionListener$HttpNIOAcceptHandler. getReadHandler(HttpConnectionListener.java:116) at oracle.oc4j.network.ReadHandlerPool.getContextFromBackend(ReadHandler Pool.java:63) at com.evermind.util.BBPool.startPool(BBPool.java:42) at oracle.oc4j.network.ReadHandlerPool.register(ReadHandlerPool.java:25) - locked &lt;0x05ec9290&gt; (a java.util.ArrayList) at oracle.oc4j.network.ServerSocketAcceptHandler.setPoolOptions(ServerSo cketAcceptHandler.java:140) at com.evermind.server.http.HttpConnectionListener.setRequestHandlerPool (HttpConnectionListener.java:232) at com.evermind.server.http.HttpConnectionListener.initHandlers(HttpConn ectionListener.java:226) at com.evermind.server.http.HttpConnectionListener.&lt;init&gt;(HttpConnection Listener.java:174) at com.evermind.server.http.HttpServer.getListener(HttpServer.java:481) - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer) at com.evermind.server.http.HttpServer.setSites(HttpServer.java:267) - locked &lt;0x05ec4f88&gt; (a com.evermind.server.http.HttpServer) at com.evermind.server.http.HttpServer.setConfig(HttpServer.java:180) at com.evermind.server.ApplicationServer.initializeHttp(ApplicationServe r.java:2296) at com.evermind.server.ApplicationServer.setConfig(ApplicationServer.jav a:944) at com.evermind.server.ApplicationServerLauncher.run(ApplicationServerLa uncher.java:113) - locked &lt;0x0530eb20&gt; (a java.lang.Object) at java.lang.Thread.run(Thread.java:595) Found 1 deadlock.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java</file><file>weaver/src/org/aspectj/weaver/tools/AbstractTrace.java</file><file>weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java</file><file>weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java</file></fixedFiles></bug><bug commit="04fa1dc" fixdate="1156440000" id="129525" opendate="1141030000" status="resolved fixed"><buginformation><summary>129525 Don't Dump Bytecodes to Syserr in LTW</summary><description>The load-time weaving system can produce truly massive quantities of output when there's a weaving error, since the system dumps the bytecode to syserr. It would be much better to produce an ajcore file and just point to it, or use some other log.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="8549d86" fixdate="1156330000" id="150271" opendate="1152630000" status="resolved fixed"><buginformation><summary>150271 Allow multiple levels of LTW information</summary><description>It would be nice if basic information about load-time weaving (what version of AspectJ is being used, what loaders are doing weaving and what configuration is being used) was available without all of the -verbose information listing of all classes woven or not woven. It's also unfortunate that the flags for weaving level are 2 quite different ones: -Daj.weaving.verbose -Dorg.aspectj.weaver.showWeaveInfo Why not something like -Dorg.aspectj.weaver.level=[none|summary|info|verbose] summary: just what configuration is used info: list affected join points etc. (like showWeaveInfo) verbose: all (like verbose now)</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/Options.java</file><file>tests/java5/ataspectj/ataspectj/TestHelper.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="59123b0" fixdate="1155890000" id="154332" opendate="1155890000" status="resolved fixed"><buginformation><summary>154332 [annotations] Incorrect handling of java.lang annotations when matching</summary><description>As raised by Mr Bodkin on the list: Can anyone tell me why this compiling this program produces warnings for marker but not for deprecated (in a recent dev build of AJDT)? Is this just a bug? Both have runtime retention, so I would expect equivalent behavior. @Deprecated @Marker public aspect Annot { pointcut test() : within(@Marker *);// *); declare warning: staticinitialization(@Deprecated *): "deprecated"; declare warning: staticinitialization(@Marker *): "marker"; public static void main(String argz[]) { new Baz().foo(); } } @Deprecated @Marker class Baz { public void foo() {} } @Retention(RetentionPolicy.RUNTIME) public @interface Marker { }</description></buginformation><fixedFiles><file>tests/bugs153/pr154332/Annot.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java</file></fixedFiles></bug><bug commit="82e3e13" fixdate="1155640000" id="153535" opendate="1155280000" status="resolved fixed"><buginformation><summary>153535 Bug in reflection delegate signature for array of object type</summary><description>The following problem is interesting because the advice weaves correctly with Java 1.5 LTW and also using Java 1.4 with build-time weaving. However, the following call pointcut isn't matching the expected call site in Java 1.4 load-time weaving (*). Pointcut: private pointcut inExecQuery() : (within(uk.ltd.getahead.dwr.impl.ExecuteQuery) || within(uk.ltd.getahead.dwr.ExecuteQuery)); public pointcut dwrQuery(Method method, Object receiver, Object[] params) : inExecQuery() &amp;&amp; withincode(* execute(..)) &amp;&amp; call(* Method.invoke(..)) &amp;&amp; args(receiver, params) &amp;&amp; target(method); protected pointcut monitorEnd() : dwrQuery(*, *, *); Matching call site: Object reply = method.invoke(object, params); I've tracked it down to failing to find the method in ResolvedType.matches. On line 405: "m1.getSignature()"= "(Ljava/lang/Object;[Ljava.lang.Object;)Ljava/lang/Object;" "m2.getSignature()"= "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;" Note the difference between . and / ^ ^ It looks to me like the signature for array types in the reflection delegate is erroneously using . instead of /. I have attached a patch to the ReflectionBasedReferenceTypeDelegateTest that isolates this unexpected signature return. Hopefully you agree that this is not correct. If not, some more information follows. Here's the stack trace where the match fails: ResolvedType.matches(Member, Member) line: 405 ReferenceType(ResolvedType).lookupMember(Member, Iterator) line: 347 ReferenceType(ResolvedType).lookupMethod(Member) line: 326 LTWWorld(World).resolve(Member) line: 504 MemberImpl.resolve(World) line: 93 JoinPointSignatureIterator.addSignaturesUpToFirstDefiningMember() line: 109 JoinPointSignatureIterator.&lt;init&gt;(Member, World) line: 51 MemberImpl.getJoinPointSignatures(World) line: 943 SignaturePattern.matches(Member, World, boolean) line: 286 KindedPointcut.matchInternal(Shadow) line: 106 KindedPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 53 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 AndPointcut.matchInternal(Shadow) line: 51 AndPointcut(Pointcut).match(Shadow) line: 146 OrPointcut.matchInternal(Shadow) line: 50 OrPointcut(Pointcut).match(Shadow) line: 146 BcelAdvice(ShadowMunger).match(Shadow, World) line: 71 BcelAdvice(Advice).match(Shadow, World) line: 112 BcelAdvice.match(Shadow, World) line: 107 BcelClassWeaver.match(BcelShadow, List) line: 2806 BcelClassWeaver.matchInvokeInstruction(LazyMethodGen, InstructionHandle, InvokeInstruction, BcelShadow, List) line: 2768 BcelClassWeaver.match(LazyMethodGen, InstructionHandle, BcelShadow, List) line: 2506 BcelClassWeaver.match(LazyMethodGen) line: 2332 BcelClassWeaver.weave() line: 494 BcelClassWeaver.weave(BcelWorld, LazyClassGen, List, List, List) line: 119 BcelWeaver.weave(UnwovenClassFile, BcelObjectType, boolean) line: 1613 BcelWeaver.weaveWithoutDump(UnwovenClassFile, BcelObjectType) line: 1564 BcelWeaver.weaveAndNotify(UnwovenClassFile, BcelObjectType, IWeaveRequestor) line: 1341 BcelWeaver.weave(IClassFileProvider) line: 1163 ClassLoaderWeavingAdaptor(WeavingAdaptor).getWovenBytes(String, byte[]) line: 319 ClassLoaderWeavingAdaptor(WeavingAdaptor).weaveClass(String, byte[]) line: 225 Aj.preProcess(String, byte[], ClassLoader) line: 77 ClassPreProcessorAdapter.preProcess(String, byte[], ClassLoader) line: 67 ClassPreProcessorHelper.defineClass0Pre(ClassLoader, String, byte[], int, int, ProtectionDomain) line: 107 WebappClassLoader(ClassLoader).defineClass(String, byte[], int, int, ProtectionDomain) line: 539 WebappClassLoader(SecureClassLoader).defineClass(String, byte[], int, int, CodeSource) line: 123 WebappClassLoader.findClassInternal(String) line: 1786 WebappClassLoader.findClass(String) line: 1048 WebappClassLoader.loadClass(String, boolean) line: 1506 WebappClassLoader.loadClass(String) line: 1385 WebappClassLoader(ClassLoader).loadClassInternal(String) line: 302 Class.forName0(String, boolean, ClassLoader) line: not available [native method] Class.forName(String) line: 141 InitializeLog.setWarnLogging(String) line: 121 InitializeLog.initializeLogging() line: 96 ContextLoaderServlet.init() line: 13 ContextLoaderServlet(GenericServlet).init(ServletConfig) line: 212 StandardWrapper.loadServlet() line: 879 StandardWrapper.load() line: 767 StandardContext.loadOnStartup(Container[]) line: 3483 StandardContext.start() line: 3709 StandardHost(ContainerBase).addChildInternal(Container) line: 776 StandardHost(ContainerBase).addChild(Container) line: 759 StandardHost.addChild(Container) line: 537 StandardHostDeployer.install(String, URL) line: 260 StandardHost.install(String, URL) line: 730 HostConfig.deployWARs(File, String[]) line: 558 HostConfig.deployApps() line: 373 HostConfig.start() line: 784 HostConfig.lifecycleEvent(LifecycleEvent) line: 330 LifecycleSupport.fireLifecycleEvent(String, Object) line: 119 StandardHost(ContainerBase).start() line: 1155 StandardHost.start() line: 696 StandardEngine(ContainerBase).start() line: 1147 StandardEngine.start() line: 310 StandardService.start() line: 449 StandardServer.start() line: 2212 Catalina.start() line: 458 Catalina.execute() line: 345 Catalina.process(String[]) line: 129 NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method] NativeMethodAccessorImpl.invoke(Object, Object[]) line: 39 DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 25 Method.invoke(Object, Object[]) line: 324 Bootstrap.main(String[]) line: 150 I'm using a modified version of Alex Vasseur's LTW plugin for a Java 1.4 VM although I haven't tested on the JRockIt plugin for a 1.4 VM: my guess is that this would fail there too.</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java</file><file>weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java</file><file>weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java</file></fixedFiles></bug><bug commit="a38edd3" fixdate="1155040000" id="152388" opendate="1154390000" status="resolved fixed"><buginformation><summary>152388 NPE in MessageUtil.addExtraSourceLocations</summary><description>I get this message from an error in a recent dev build of AspectJ with load-time weaving. I don't know how there is a null source location associated with this message, but either it shouldn't be there or MessageUtil line 806 should use this patch: Index: src/org/aspectj/bridge/MessageUtil.java =================================================================== RCS file: /home/technology/org.aspectj/modules/bridge/src/org/aspectj/bridge/MessageUtil.java,v retrieving revision 1.11 diff -u -r1.11 MessageUtil.java --- src/org/aspectj/bridge/MessageUtil.java 1 Jun 2006 09:36:37 -0000 1.11 +++ src/org/aspectj/bridge/MessageUtil.java 31 Jul 2006 22:32:16 -0000 @@ -803,7 +803,7 @@ writer.println(baseMessage); for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) { ISourceLocation element = (ISourceLocation) iter.next(); - writer.print("\tsee also: " + element.toString()); + writer.print("\tsee also: " + element); if (iter.hasNext()) { writer.println(); } NPE follows: java.lang.NullPointerException at org.aspectj.bridge.MessageUtil.addExtraSourceLocations(MessageUtil.java:806) at org.aspectj.bridge.MessageUtil.renderMessage(MessageUtil.java:793) at org.aspectj.bridge.Message.toString(Message.java:177) at org.aspectj.bridge.MessageWriter.render(MessageWriter.java:73) at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.render(WeavingAdaptor.java:471) at org.aspectj.bridge.MessageWriter.handleMessage(MessageWriter.java:41) at org.aspectj.weaver.tools.WeavingAdaptor$WeavingAdaptorMessageHandler.handleMessage(WeavingAdaptor.java:425) at org.aspectj.weaver.bcel.BcelTypeMunger.error(BcelTypeMunger.java:378) at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:273) at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194) at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:450) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1613) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1564) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1341) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1163) at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:288) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:214) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:76) at org.aspectj.ext.ltw13.ClassPreProcessorAdapter.preProcess(ClassPreProcessorAdapter.java:65) at org.codehaus.aspectwerkz.hook.impl.ClassPreProcessorHelper.defineClass0Pre(ClassPreProcessorHelper.java:107) at java.lang.ClassLoader.defineClass(ClassLoader.java:539) ... NOTE: I'm using Alex Vasseur's adaptor to invoke AspectJ LTW from a 1.4 VM, but with recursion protection added. I don't think that should change the expected behavior of Aj.</description></buginformation><fixedFiles><file>bridge/src/org/aspectj/bridge/MessageUtil.java</file></fixedFiles></bug><bug commit="f239f2a" fixdate="1155020000" id="152873" opendate="1154720000" status="resolved fixed"><buginformation><summary>152873 Optimize shouldWeaveAnnotationStyleAspect with Patch</summary><description /></buginformation><fixedFiles><file>testing/newsrc/org/aspectj/testing/AntSpec.java</file><file>tests/java5/ataspectj/ataspectj/bugs/NotAspect.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java</file><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/src/org/aspectj/weaver/tools/IsAtAspectAnnotationVisitor.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="ff2377a" fixdate="1154690000" id="152631" opendate="1154540000" status="resolved fixed"><buginformation><summary>152631 Problem with decp on an aspect using cflow</summary><description>This occurs in the AspectJ build in AJDT from August 1 but not from July 31: java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelTypeMunger.enforceDecpRule1_abstractMethodsImplemented(BcelTypeMunger.java:250) at org.aspectj.weaver.bcel.BcelTypeMunger.mungeNewParent(BcelTypeMunger.java:194) at org.aspectj.weaver.bcel.BcelTypeMunger.munge(BcelTypeMunger.java:106) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:454) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:119) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1597) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1548) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1328) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1124) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.weaveQueuedEntries(AjPipeliningCompilerAdapter.java:451) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.queueForWeaving(AjPipeliningCompilerAdapter.java:389) at org.aspectj.ajdt.internal.compiler.AjPipeliningCompilerAdapter.afterProcessing(AjPipeliningCompilerAdapter.java:377) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$after$org_aspectj_ajdt_internal_compiler_CompilerAdapter$5$6b855184(CompilerAdapter.aj:98) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:533) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:891) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:246) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:165) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in:public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect extends java.lang.Object implements glassbox.agent.api.NotSerializable: private static Throwable ajc$initFailureCause [Synthetic] public static final glassbox.agent.ErrorContainmentTest$ErrorMockAspect ajc$perSingletonInstance [Synthetic] static void &lt;clinit&gt;(): catch java.lang.Throwable -&gt; E0 | INVOKESTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$postClinit ()V (line 60) catch java.lang.Throwable -&gt; E0 GOTO L0 E0: ASTORE_0 ALOAD_0 PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable; L0: RETURN end static void &lt;clinit&gt;() void &lt;init&gt;(): ALOAD_0 // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this (line 60) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V RETURN end void &lt;init&gt;() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc() AdviceAttribute(before, (scope() &amp;&amp; call(* hook1())), 0, 1670) : NEW java.lang.RuntimeException (line 64) DUP LDC "rte" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$1$9589fc() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2() AdviceAttribute(before, execution(* glassbox.agent.ErrorContainmentTest.hook5()), 0, 1764) : NEW java.lang.RuntimeException (line 67) DUP LDC "rte" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$2$f75db3e2() public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure) AdviceAttribute(around, (scope() &amp;&amp; call(* hook2())), 1, 1913) : NEW java.lang.Error (line 71) DUP LDC "foo" INVOKESPECIAL java.lang.Error.&lt;init&gt; (Ljava/lang/String;)V ATHROW end public void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17d(org.aspectj.runtime.internal.AroundClosure) static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable org.aspectj.weaver.AjAttribute$AjSynthetic@19a01f9 : ALOAD_0 // Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; this (line 1) ICONST_0 ANEWARRAY java.lang.Object INVOKEVIRTUAL org.aspectj.runtime.internal.AroundClosure.run ([Ljava/lang/Object;)Ljava/lang/Object; INVOKESTATIC org.aspectj.runtime.internal.Conversions.voidValue (Ljava/lang/Object;)Ljava/lang/Object; RETURN end static void ajc$around$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$3$a3a17dproceed(org.aspectj.runtime.internal.AroundClosure) throws java.lang.Throwable public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f() AdviceAttribute(after, (scope() &amp;&amp; call(* hook4())), 0, 1991) : NEW org.aspectj.lang.SoftException (line 74) DUP ACONST_NULL INVOKESPECIAL org.aspectj.lang.SoftException.&lt;init&gt; (Ljava/lang/Throwable;)V ATHROW end public void ajc$after$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$4$bfd07f() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc() AdviceAttribute(before, logErrorInTest(), 0, 2446) : GETSTATIC glassbox.agent.ErrorContainmentTest.logCount I (line 84) ICONST_1 IADD PUTSTATIC glassbox.agent.ErrorContainmentTest.logCount I RETURN (line 85) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$5$e5bddfdc() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 2506) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 87) LDC "match" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 88) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$6$16ecfe62() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest))))), 0, 2721) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 90) LDC "match in test" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 91) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$7$e9ae8482() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; cflow(logError()))), 0, 2923) : GETSTATIC java.lang.System.err Ljava/io/PrintStream; (line 93) LDC "match in log" INVOKEVIRTUAL java.io.PrintStream.println (Ljava/lang/String;)V RETURN (line 94) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$8$c6ac5351() public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62() AdviceAttribute(before, (adviceexecution(* *) &amp;&amp; (within(glassbox.util.logging.api.LogManagement) &amp;&amp; (cflow(logError()) &amp;&amp; cflow((execution(* testLoggingError(..)) &amp;&amp; within(glassbox.agent.ErrorContainmentTest)))))), 0, 3069) : GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I (line 96) ICONST_1 IADD PUTSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I GETSTATIC glassbox.agent.ErrorContainmentTest.recursiveThrows I (line 97) ICONST_2 IF_ICMPGE L0 NEW java.lang.RuntimeException (line 98) DUP LDC "recursive logging failure" INVOKESPECIAL java.lang.RuntimeException.&lt;init&gt; (Ljava/lang/String;)V ATHROW L0: RETURN (line 100) end public void ajc$before$glassbox_agent_ErrorContainmentTest$ErrorMockAspect$9$16ecfe62() public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf() org.aspectj.weaver.AjAttribute$AjSynthetic@3cd8fe : GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; (line 1) IFNONNULL L0 NEW org.aspectj.lang.NoAspectBoundException DUP LDC "glassbox_agent_ErrorContainmentTest$ErrorMockAspect" GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$initFailureCause Ljava/lang/Throwable; INVOKESPECIAL org.aspectj.lang.NoAspectBoundException.&lt;init&gt; (Ljava/lang/String;Ljava/lang/Throwable;)V ATHROW L0: GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; ARETURN end public static glassbox.agent.ErrorContainmentTest$ErrorMockAspect aspectOf() public static boolean hasAspect() org.aspectj.weaver.AjAttribute$AjSynthetic@1bd4f6 : GETSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; (line 1) IFNULL L0 ICONST_1 IRETURN L0: ICONST_0 IRETURN end public static boolean hasAspect() private static void ajc$postClinit() org.aspectj.weaver.AjAttribute$AjSynthetic@1febf91 : NEW glassbox.agent.ErrorContainmentTest$ErrorMockAspect (line 1) DUP INVOKESPECIAL glassbox.agent.ErrorContainmentTest$ErrorMockAspect.&lt;init&gt; ()V PUTSTATIC glassbox.agent.ErrorContainmentTest$ErrorMockAspect.ajc$perSingletonInstance Lglassbox/agent/ErrorContainmentTest$ErrorMockAspect; RETURN end private static void ajc$postClinit() end public class glassbox.agent.ErrorContainmentTest$ErrorMockAspect when type munging with (BcelTypeMunger ResolvedTypeMunger(Parent, null)) when weaving aspects when weaving when batch building BuildConfig[C:\devel\glassbox\.metadata\.plugins\org.eclipse.ajdt.core\glassboxMonitor.generated.lst] #Files=107 The source is: public class ErrorContainmentTest extends TestCase { ... static aspect ErrorMockAspect implements NotSerializable { ... I will try to narrow this down if the problem isn't obvious.</description></buginformation><fixedFiles><file>tests/bugs153/pr152631/EMA.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="9664058" fixdate="1154590000" id="152589" opendate="1154530000" status="resolved fixed"><buginformation><summary>152589 [pipeline] adding a whitespace results in adviceDidNotMatch warning</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file></fixedFiles></bug><bug commit="bebb364" fixdate="1154460000" id="151938" opendate="1153960000" status="resolved fixed"><buginformation><summary>151938 Handle Duplicate -javaagent entries more gracefully</summary><description>If you start a java 5 VM with AspectJ's load-time weaver specified more than once using the -javaagent flag, if there is an aop.xml file defined, it chokes badly: it tries to reweave the woven AspectJ code and emits massive amounts of bytecode. It would be better if AspectJ detected that it was specified more than once and gave a warning then disabled all but one of the agents. Failing that, it would be better to fail and give an error message than emit the bytecode. This issue came up for our automated installer, which adds a -javaagent flag to VM startup commands. If the script is wrapped twice, it can generate a duplicate. We are making our scripts more intelligent to avoid this issue, but we are probably not the only people who will hit this issue (e.g., if someone manually edits both setclasspath.bat and catalina.bat to add the flag for a Tomcat instance...)</description></buginformation><fixedFiles><file>loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java</file><file>tests/java5/ataspectj/HelloWorld.java</file><file>tests/java5/ataspectj/MessageHandler.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file></fixedFiles></bug><bug commit="e4ab0ae" fixdate="1153990000" id="151673" opendate="1153820000" status="resolved fixed"><buginformation><summary>151673 Incorrect weaving of after returning when 'input' bytecode is of a strange form</summary><description>We have had a user report a problem where after advice being woven into a particular method is producing code that does not verify. The problem occurs if the bytecode being input to the weaving process includes a subroutine that contains the return from the method. Here is the problematic snippet produced by some unknown compiler: 200: invokespecial #17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V 203: athrow 204: aload_3 205: astore 6 207: jsr 234 210: aload 6 212: areturn 213: astore 4 215: aload 4 217: invokevirtual #79; //Method java/lang/Throwable.printStackTrace:()V 220: jsr 234 223: goto 238 226: astore 7 228: jsr 234 231: aload 7 233: athrow 234: astore 8 236: aload_3 237: areturn 238: return Exception table: from to target type 2 213 213 Class javax/ejb/FinderException 2 226 226 any see the jsr's jump to 234, but before the subroutine return at 238 there is an areturn out of the method (this method returns a String). After weaving we get something like this: 200: invokespecial #17; //Method com/MyException."&lt;init&gt;":(Ljava/lang/String;)V 203: athrow 204: aload_3 205: astore 6 207: jsr 238 210: aload 6 212: astore 9 214: goto 248 217: astore 4 219: aload 4 221: invokevirtual #79; //Method java/lang/Throwable.printStackTrace:()V 224: jsr 238 227: goto 246 230: astore 7 232: jsr 238 235: aload 7 237: athrow 238: astore 8 240: aload_3 241: astore 9 243: goto 248 246: astore 9 248: invokestatic #299; //Method After.aspectOf:()LAfter; 251: invokevirtual #302; //Method After.ajc$afterReturning$After$1$26d6d4a7:()V 254: aload 9 256: return see how the areturn has been lost - this code will blow up with a verify error (the string is on the stack, we just ignore it and 'return' normally)</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="54f7bb4" fixdate="1153990000" id="151845" opendate="1153920000" status="resolved fixed"><buginformation><summary>151845 NPE while building</summary><description>Building of a large project fails while weaving. NPE in EclipseSourceContext.removeUnnecessaryProblems(..) The project was just migrated to Eclipse 3.2 Eclipse newly installed with Eclipse SDK and via Update manager with AJDT, CDT, Web/J2EE tools, SubClipse, SpringIDE. Same Project workes in Eclipse 3.1. Simple Test AspectJ-Project workes OK Building with Ant/AspectJ compiler (as external Tools Launch in Eclipse) works. I tried the following, but got the error anyway: - Checked out as a new AspectJ Project - upgraded to the developement Version of AJDT</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java</file></fixedFiles></bug><bug commit="397a19d" fixdate="1153990000" id="151182" opendate="1153380000" status="resolved fixed"><buginformation><summary>151182 NPE in BcelWeaver using LTW</summary><description>Hi, I created a logging aspect for our application some time ago using 1.5.0 of AspectJ. I enabled this from time to time using Load Time Weaving. I have recently recompiled the aspect using 1.5.2 and tried to run it also using the 1.5.2 weaver jar, but it fails with a NullPointerException. This is part of one of the many stacktraces: 20 jul 2006 07:42:49,046 - java.lang.NullPointerException 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1367) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1237) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1072) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.tools.WeavingAdaptor.getWovenBytes(WeavingAdaptor.java:284) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:212) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65) 20 jul 2006 07:42:49,062 - at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55) 20 jul 2006 07:42:49,062 - at sun.instrument.TransformerManager.transform(Unknown Source) 20 jul 2006 07:42:49,062 - at sun.instrument.InstrumentationImpl.transform(Unknown Source) 20 jul 2006 07:42:49,062 - at java.lang.ClassLoader.defineClass1(Native Method) 20 jul 2006 07:42:49,062 - at java.lang.ClassLoader.defineClass(Unknown Source) I then tried with the 1.5.0 weaver jar (although the aspect was compiled using 1.5.2) and this ran without problems.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/Aj.java</file></fixedFiles></bug><bug commit="357bbe9" fixdate="1153810000" id="150671" opendate="1152890000" status="resolved fixed"><buginformation><summary>150671 declare error on set of volatile field does not work</summary><description>When an aspect has a declare error statement involving a pointcut that captures the setting of a volatile field, a compilation error is not produced. This bug can be reproduced as follows. Consider the following class: class A { private volatile int state; public void foo() { state = 0; } } Now consider this aspect: aspect FSM { declare error: set(* A.state): "Changing state"; } The setting of the state field in method foo() does not result in a compilation error as expected. I originally noticed this bug when using AJDT 1.4 with Eclipse 3.2. However this has been reproduced and confirmed with the aspectj 1.5.2 compiler.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java</file></fixedFiles></bug><bug commit="369de87" fixdate="1152190000" id="148409" opendate="1151080000" status="resolved fixed"><buginformation><summary>148409 [generics] ClassCastException in UnresolvedType.java:348</summary><description>I am using AspectJ load time weaving with Spring 2.0 RC1 to inject my entities, and I am getting the following exception: java.lang.ClassCastException: org.aspectj.apache.bcel.classfile.Signature$TypeVariableSignature at org.aspectj.weaver.UnresolvedType.forGenericTypeSignature(UnresolvedType.java:348) at org.aspectj.weaver.bcel.BcelWorld.addSourceObjectType(BcelWorld.java:385) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.accept(ClassLoaderWeavingAdaptor.java:492) at org.aspectj.weaver.tools.WeavingAdaptor.shouldWeave(WeavingAdaptor.java:230) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass(WeavingAdaptor.java:210) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:65) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform(ClassPreProcessorAgentAdapter.java:55) at sun.instrument.TransformerManager.transform(TransformerManager.java:122) at sun.instrument.InstrumentationImpl.transform(InstrumentationImpl.java:155) at java.lang.ClassLoader.defineClass1(Native Method) . . . Having examined the call stack under the debugger, this seems to happening when the weaver is attempting to determine whether a particular class should be weaved. The exception is thrown in the following method, at the cast highlighted below. public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) { UnresolvedType ret = UnresolvedType.forSignature(sig); ret.typeKind=TypeKind.GENERIC; ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig); Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters; ret.typeVariables = new TypeVariable[ftps.length]; for (int i = 0; i &lt; ftps.length; i++) { Signature.FormalTypeParameter parameter = ftps[i]; Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound; // EXCEPTION HERE! ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";")); } ret.signatureErasure = sig; ret.signature = ret.signatureErasure; return ret; } The class in question (which is not one that requires weaving), has the following signature: public class HibernateEntityDAO&lt;interfaceT extends SecurityEntity, concreteT extends interfaceT&gt; extends HibernateDaoSupport implements EntityDAO&lt;interfaceT&gt; The exception is happening because the parameter.classBound member is not of type Signature.ClassTypeSignature, but an instance of Signature.TypeVariableSignature. The loop variable i is 1, and parameter.identifier is concreteT, so it looks like it's the signature of the second type parameter (concreteT) that is tripping up the weaver.</description></buginformation><fixedFiles><file>tests/bugs153/pr148409/Blurgh.java</file><file>tests/bugs153/pr148409/X.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>weaver/src/org/aspectj/weaver/UnresolvedType.java</file></fixedFiles></bug><bug commit="82f217f" fixdate="1152090000" id="148693" opendate="1151340000" status="resolved fixed"><buginformation><summary>148693 woven class does not pass org.apache.bcel.verifier.statics.Pass2Verifier</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file><file>tests/src/org/aspectj/testing/Utils.java</file></fixedFiles></bug><bug commit="f6834c7" fixdate="1151930000" id="148737" opendate="1151370000" status="resolved fixed"><buginformation><summary>148737 IllegalStateException for non-generic type</summary><description>I believe this is similar to 112880. The message and stack trace I am getting are -- (IllegalStateException) Can't ask to parameterize a member of non-generic type: com...object kind(raw) Can't ask to parameterize a member of non-generic type: com...object kind(raw) java.lang.IllegalStateException: Can't ask to parameterize a member of non-generic type: com....object kind(raw) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:612) at org.aspectj.weaver.ResolvedMemberImpl.parameterizedWith(ResolvedMemberImpl.java:597) at org.aspectj.weaver.ReferenceType.getDeclaredMethods(ReferenceType.java:508) at org.aspectj.weaver.ResolvedType$4.get(ResolvedType.java:225) at org.aspectj.weaver.Iterators$3$1.hasNext(Iterators.java:118) at org.aspectj.weaver.Iterators$5.hasNext(Iterators.java:171) at org.aspectj.weaver.Iterators$3.hasNext(Iterators.java:128) at org.aspectj.weaver.ResolvedType.lookupMember(ResolvedType.java:345) at org.aspectj.weaver.ResolvedType.lookupMethod(ResolvedType.java:326) . . . The same code was able to be weaved under 1.5.0. The reason why this is a major issue is 1.5.0 suffers from a StackOverflowException.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>tests/bugs153/pr148737/A.java</file><file>tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java</file></fixedFiles></bug><bug commit="2f2f568" fixdate="1151500000" id="148972" opendate="1151490000" status="resolved fixed"><buginformation><summary>148972 problems with binary weaving declare parents in mixed environment.</summary><description>These have been reported to me on a large system doing some intricate weaving where some classes are 1.2, some 1.4, some 1.5 and the VM is 1.5. Binary weaving declare parents sometimes refuses to allow the modification of the hierarchy because it sees a clash between two methods when there is none. The two cases I'm fixing are: 1. sometimes the signatures of the return types differ with the '.' or '/' problem (fix == be consistent) 2. sometimes the syntheticness of the methods in the relationship isn't determined correctly</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="21e06a6" fixdate="1151490000" id="148727" opendate="1151350000" status="resolved fixed"><buginformation><summary>148727 Can't call synthetic aspectOf method on aspect in library jar</summary><description>Separate compilation of the following program breaks on 1.5.2rc1 because of the recent change to marking aspect methods as synthetic: public aspect Asp { } public class Client { public static void main(String argz[]) { System.out.println("Can call aspectOf? "+Asp.aspectOf()); } } C:\devel\scratch\synthetic&gt;ajc -classpath asp.jar;%CLASSPATH% Client.java C:\devel\scratch\synthetic\Client.java:3 [error] The method aspectOf() is undefi ned for the type Asp System.out.println("Can call aspectOf? "+Asp.aspectOf()); 1 error C:\devel\scratch\synthetic&gt;javac -classpath asp.jar;%CLASSPATH% Client.java Client.java:3: cannot find symbol symbol : method aspectOf() location: class Asp System.out.println("Can call aspectOf? "+Asp.aspectOf()); ^ 1 error Clearly it's vital that external users of a library be able to call API methods like aspectOf on library aspects. This works: C:\devel\scratch\synthetic&gt;ajc *.aj Client.java C:\devel\scratch\synthetic&gt;java Client Can call aspectOf? Asp@b89838 Patch with test integrated into CVS tree to follow...</description></buginformation><fixedFiles><file>tests/bugs152/pr148727/Client.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/NameMangler.java</file></fixedFiles></bug><bug commit="99d1c18" fixdate="1151430000" id="148388" opendate="1151070000" status="resolved fixed"><buginformation><summary>148388 LTW weaver produces a debug message at the begining</summary><description /></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="792d1df" fixdate="1151410000" id="148786" opendate="1151400000" status="resolved fixed"><buginformation><summary>148786 new array construction join point can fail for freaky array constructors</summary><description>Took me a while to discover how to recreate this problem, but this class: public class A { public static void main(String []argv) { byte[][] bytes = new byte[][]{{0},{1}}; } } causes this bytecode: 0: iconst_2 1: anewarray #18; //class "[B" and this causes the newarray joinpoint code to go bang. (eg. before(): call(*[].new(..)) {}) java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelWorld.fromBcel(BcelWorld.java:236) at org.aspectj.weaver.bcel.BcelWorld.makeJoinPointSignatureForArrayConstruction(BcelWorld.java:483) at org.aspectj.weaver.bcel.BcelShadow.makeArrayConstructorCall(BcelShadow.java:801) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2510) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2325) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:490) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:115) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127)</description></buginformation><fixedFiles><file>tests/bugs152/pr148786/A.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWorld.java</file></fixedFiles></bug><bug commit="13dde4e" fixdate="1150890000" id="147801" opendate="1150750000" status="resolved fixed"><buginformation><summary>147801 java.lang.ClassFormatError: Repetitive method name/signature</summary><description>I get a ClassFormatError trying to perform runtime-weaving on a DB2 class. The class being woven is COM.ibm.db2.jdbc.app.DB2PreparedStatement. The full message exception is: java.lang.ClassFormatError: Repetitive method name/signature in class file COM/ibm/db2/jdbc/app/DB2PreparedStatement. In examining the post-weave class file, it looks as if Aspectj is defining a duplicate method within the class called getParameterMetaData(). Here are the messages from the weaver: 04:21:13,640 INFO [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2CallableStatement' 04:21:13,640 INFO [STDOUT] info weaver operating in reweavable mode. Need to verify any required types exist. 04:21:13,671 INFO [STDOUT] info weaving 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' 04:21:13,671 INFO [STDOUT] info weaver operating in reweavable mode. Need to verify any required types exist. 04:21:13,703 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:747) [with runtime test] 04:21:13,703 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(java.sql.ResultSet COM.ibm.db2.jdbc.app.DB2PreparedStatement.executeQuery())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:1679) advised by afterThrowing advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:971) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by before advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:833) [with runtime test] 04:21:13,718 INFO [STDOUT] weaveinfo Join point 'method-execution(boolean COM.ibm.db2.jdbc.app.DB2PreparedStatement.execute())' in Type 'COM.ibm.db2.jdbc.app.DB2PreparedStatement' (DB2PreparedStatement.java:3971) advised by afterReturning advice from 'com.ibm.tivoli.itcam.toolkit.ai.aspectj.captureJDBC.CaptureSQLStatement' (CaptureSQLStatement.aj:946) [with runtime test]</description></buginformation><fixedFiles><file>tests/bugs152/pr147801/Foo.java</file><file>tests/bugs152/pr147801/PreparedStatement.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java</file></fixedFiles></bug><bug commit="008efca" fixdate="1150230000" id="136707" opendate="1144950000" status="resolved fixed"><buginformation><summary>136707 iajc should print summary like javac</summary><description>The iajc ant task should produce a summary of what it is doing, like the javac task does: [javac] Compiling 189 source files to C:\project\classes</description></buginformation><fixedFiles><file>taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java</file><file>taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java</file></fixedFiles></bug><bug commit="38cc0dd" fixdate="1150120000" id="146546" opendate="1150110000" status="resolved fixed"><buginformation><summary>146546 Remove hard coded dependency on "|" in getFileName(..) methods</summary><description /></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/AsmManager.java</file><file>asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java</file></fixedFiles></bug><bug commit="75afb31" fixdate="1149850000" id="122580" opendate="1136340000" status="resolved fixed"><buginformation><summary>122580 Fix &amp; Bug: Circularity Failure for Verbose Loading on JRockit 1.4.2_08 Agent</summary><description>Here is a stack trace I am getting when I try to use AspectJ 1.5.0 final release's load-time weaving with JRockIt 1.4.2_08 using -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent to load Weblogic Server 8.1 SP2. I debugged the code in Eclipse and discovered that the weaver was being initialized while loading IMessage$Kind, so the JRockIt VM simply hasn't run staticinitialization yet, making IMessage.INFO null. I was able to fix this stack trace by hoisting the check for loading AspectJ code up BEFORE initializing a weaving adaptor i.e., changing line 55 of Aj.java to be if (loader == null || className == null || className.startsWith("org/aspectj/")) { I then commented out line 251 of WeavingAdaptor to avoid a duplicate check: private boolean shouldWeaveName (String name) { return !((/*(name.startsWith("org.apache.bcel.")||//FIXME AV why ? bcel is wrapped in org.aspectj. name.startsWith("org.aspectj.")||*/ // now checked earlier, to avoid circularity issues in initialization name.startsWith("java.") || name.startsWith("javax.")) //|| name.startsWith("$Proxy")//JDK proxies//FIXME AV is that 1.3 proxy ? fe. ataspect.$Proxy0 is a java5 proxy... || name.startsWith("sun.reflect."));//JDK reflect } Note that this bug does NOT occur when using a JRockIt 1.5.0 VM, even with the -Xmanagement command line argument. Stack Trace: java.lang.IllegalArgumentException: null kind at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168) at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70) at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94) at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61) at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74) at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source) at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source) at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source) at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123) at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55) at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194) at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source) at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source) at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274) at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source) at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source) at jrockit.vm.RNI.trampoline()V(Unknown Source) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:???) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) java.lang.IllegalArgumentException: null kind at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;ZIII)V(Message.java:89) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Lorg/aspectj/bridge/ISourceLocation;Ljava/lang/Throwable;[Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:67) at org.aspectj.bridge.Message.&lt;init&gt;(Ljava/lang/String;Lorg/aspectj/bridge/IMessage$Kind;Ljava/lang/Throwable;Lorg/aspectj/bridge/ISourceLocation;)V(Message.java:110) at org.aspectj.bridge.MessageUtil.info(Ljava/lang/String;)Lorg/aspectj/bridge/IMessage;(MessageUtil.java:211) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:98) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168) at org.aspectj.weaver.tools.WeavingAdaptor.&lt;init&gt;()V(WeavingAdaptor.java:80) at org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptor.&lt;init&gt;(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)V(ClassLoaderWeavingAdaptor.java:70) at org.aspectj.weaver.loadtime.Aj$WeaverContainer.getWeaver(Ljava/lang/ClassLoader;Lorg/aspectj/weaver/loadtime/IWeavingContext;)Lorg/aspectj/weaver/tools/WeavingAdaptor;(Aj.java:94) at org.aspectj.weaver.loadtime.Aj.preProcess(Ljava/lang/String;[BLjava/lang/ClassLoader;)[B(Aj.java:61) at org.aspectj.weaver.loadtime.JRockitAgent.preProcess(Ljava/lang/ClassLoader;Ljava/lang/String;[B)[B(JRockitAgent.java:74) at jrockit.vm.ClassPreProcessorManager.notifyClassPreProcessor(ILjava/lang/String;[B)[B(Unknown Source) at jrockit.vm.Classes.defineClass0(ILjava/lang/String;[BII)I(Unknown Source) at jrockit.vm.Classes.defineClass(Ljava/lang/ClassLoader;Ljava/lang/String;[BII)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/ProtectionDomain;)Ljava/lang/Class;(Unknown Source) at java.security.SecureClassLoader.defineClass(Ljava/lang/String;[BIILjava/security/CodeSource;)Ljava/lang/Class;(SecureClassLoader.java:123) at java.net.URLClassLoader.defineClass(Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(Ljava/net/URLClassLoader;Ljava/lang/String;Lsun/misc/Resource;)Ljava/lang/Class;(URLClassLoader.java:55) at java.net.URLClassLoader$1.run()Ljava/lang/Object;(URLClassLoader.java:194) at jrockit.vm.AccessController.do_privileged_exc(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;I)Ljava/lang/Object;(Unknown Source) at jrockit.vm.AccessController.doPrivileged(Ljava/security/PrivilegedExceptionAction;Ljava/security/AccessControlContext;)Ljava/lang/Object;(Unknown Source) at java.net.URLClassLoader.findClass(Ljava/lang/String;)Ljava/lang/Class;(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Unknown Source) at sun.misc.Launcher$AppClassLoader.loadClass(Ljava/lang/String;Z)Ljava/lang/Class;(Launcher.java:274) at java.lang.ClassLoader.loadClass(Ljava/lang/String;)Ljava/lang/Class;(Unknown Source) at java.lang.ClassLoader.loadClassFromNative(II)Ljava/lang/Class;(Unknown Source) at jrockit.vm.RNI.getRunnableCode(I)I(Unknown Source) at jrockit.vm.RNI.trampoline()V(Unknown Source) at org.aspectj.bridge.MessageUtil.info(Lorg/aspectj/bridge/IMessageHandler;Ljava/lang/String;)Z(MessageUtil.java:???) at org.aspectj.weaver.tools.WeavingAdaptor.info(Ljava/lang/String;)Z(WeavingAdaptor.java:343) at org.aspectj.weaver.tools.WeavingAdaptor.createMessageHandler()V(WeavingAdaptor.java:168)</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/Aj.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java</file><file>loadtime/testsrc/LoadtimeModuleTests.java</file><file>loadtime/testsrc/org/aspectj/bea/jvm/ClassLibraryImpl.java</file><file>loadtime/testsrc/org/aspectj/bea/jvm/JVMImpl.java</file><file>loadtime/testsrc/org/aspectj/weaver/loadtime/JRockitAgentTest.java</file></fixedFiles></bug><bug commit="f821ca3" fixdate="1149320000" id="145086" opendate="1149260000" status="resolved fixed"><buginformation><summary>145086 NPE when weak reference set in signature</summary><description>Simon ran into the same problem in setting the values. I will attach a patch to fix this, with test cases to properly verify it works in both cases. java.lang.NullPointerException at org.aspectj.runtime.reflect.SignatureImpl$CacheImpl.set(SignatureImpl.java:224) at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:57) at org.aspectj.runtime.reflect.SignatureImpl.toString(SignatureImpl.java:62)</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java</file><file>runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java</file><file>runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java</file></fixedFiles></bug><bug commit="319a0d1" fixdate="1149250000" id="132591" opendate="1142890000" status="resolved fixed"><buginformation><summary>132591 Duplicate exception with aop.xml file on aspectpath</summary><description /></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java</file><file>ajde/testsrc/org/aspectj/ajde/OutxmlTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file></fixedFiles></bug><bug commit="4513e92" fixdate="1149180000" id="120739" opendate="1134510000" status="resolved fixed"><buginformation><summary>120739 LTW Optimization: Disable World if it has No Aspects</summary><description>This optimization disables weaving for a ClassLoader where there are no aspects defined. This is actually useful if you have aspect exclusions that exclude all the aspects defined in a parent class loader. It is also helpful in the trivial/rare case where there is an aop.xml definition with no aspect definitions.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>tests/java5/ataspectj/ataspectj/ltwreweavable/EmptyAtAspect.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file></fixedFiles></bug><bug commit="6b2d9ae" fixdate="1147880000" id="138223" opendate="1145900000" status="resolved fixed"><buginformation><summary>138223 Compiler crash on two binding @xxx pcds in one compound expression</summary><description>junit.framework.AssertionFailedError: test "Double at annotation matching (no binding)" failed test "Double at annotation matching (no binding)" failed Unexpected warning messages: warning at before() : transactionalOperation() { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:20:0::0 advice defined in DoubleAnnotationMatching has not been applied [Xlint:adviceDidNotMatch] Unexpected fail messages: abort trouble in: class Foo extends java.lang.Object: void &lt;init&gt;(): ALOAD_0 // LFoo; this (line 26) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V constructor-execution(void Foo.&lt;init&gt;()) | RETURN constructor-execution(void Foo.&lt;init&gt;()) end void &lt;init&gt;() public void foo() org.aspectj.weaver.MethodDeclarationLineNumber: 28:533 : method-execution(void Foo.foo()) | RETURN (line 28) method-execution(void Foo.foo()) end public void foo() public void bar() org.aspectj.weaver.MethodDeclarationLineNumber: 30:563 : method-execution(void Foo.bar()) | RETURN (line 30) method-execution(void Foo.bar()) end public void bar() end class Foo -- (BCException) Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 org.aspectj.weaver.BCException: Impossible! annotation=[Tx] shadow=[method-execution(void Foo.foo()) at /private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:28::533] pointcut is at [/private/tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj:15::316] when implementing on shadow method-execution(void Foo.foo()) when weaving type Foo when weaving classes when weaving when batch building BuildConfig[null] #Files=1 at org.aspectj.weaver.patterns.AnnotationPointcut.findResidueInternal(AnnotationPointcut.java:201) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.IfPointcut.findResidueInternal(IfPointcut.java:173) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.AndPointcut.findResidueInternal(AndPointcut.java:93) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.patterns.OrPointcut.findResidueInternal(OrPointcut.java:96) at org.aspectj.weaver.patterns.Pointcut.findResidue(Pointcut.java:267) at org.aspectj.weaver.bcel.BcelAdvice.specializeOn(BcelAdvice.java:132) at org.aspectj.weaver.bcel.BcelShadow.prepareForMungers(BcelShadow.java:325) at org.aspectj.weaver.Shadow.implement(Shadow.java:455) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:114) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:60) at org.aspectj.tools.ajc.Main.run(Main.java:367) at org.aspectj.tools.ajc.Main.runMain(Main.java:246) at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:199) at org.aspectj.tools.ajc.Ajc.compile(Ajc.java:163) at org.aspectj.tools.ajc.AjcTestCase.ajc(AjcTestCase.java:510) at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:53) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) command was: ajc -classpath /Users/adrian/projects/aspectjdev/lib/test/aspectjrt.jar:../testing-client/bin:../runtime/bin:../aspectj5rt/bin:../lib/junit/junit.jar:../bridge/bin:../loadtime/bin:../weaver/bin:../weaver5/bin:../aj-build/jars/bridge.jar:../aj-build/jars/util.jar:../aj-build/jars/loadtime.jar:../aj-build/jars/weaver.jar:../aj-build/jars/weaver5.jar:../aj-build/jars/asm.jar:../lib/test/testing-client.jar:../lib/test/aspectjrt.jar:/tmp/ajcSandbox/ajcTest18924.tmp -1.5 /tmp/ajcSandbox/ajcTest18924.tmp/DoubleAnnotationMatching.aj -d /tmp/ajcSandbox/ajcTest18924.tmp at junit.framework.Assert.fail(Assert.java:47) at org.aspectj.tools.ajc.AjcTestCase.assertMessages(AjcTestCase.java:452) at org.aspectj.testing.CompileSpec.execute(CompileSpec.java:56) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc152.Ajc152Tests.testDoubleAnnotationMatching_pr138221(Ajc152Tests.java:37) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java</file></fixedFiles></bug><bug commit="5f6a6b1" fixdate="1147870000" id="141956" opendate="1147770000" status="resolved fixed"><buginformation><summary>141956 Null Pointer Exception when trying to skip Parent Mungers.</summary><description>I don't know much about the internal workings of aspectJ but this bug keeps popping up so I went through the trouble of checking of trying to debug it so that I could hopefully provide enough information to get it fixed. This happens while using eclipse AJDT. It never happens if I fully do a clean before rebuild. It only seems to happen when doing incrmental builds (using the project-&gt;build automatically setting). The error happens in the iterator that recursively builds a list of methods to return for matching. The error is triggered here: // we need to know if it is an interface from Parent kind munger // as those are used for @AJ ITD and we precisely want to skip those boolean shouldSkip = false; for (int j = 0; j &lt; rtx.interTypeMungers.size(); j++) { ConcreteTypeMunger munger = (ConcreteTypeMunger) rtx.interTypeMungers.get(j); if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) { shouldSkip = true; break; } } munger.getMunger() returns null because the munger instance is a BcelPerClauseAspectAdder. My naive fix would be to check munger.getMunger() == null or check munger.getKind(). I'm assuming that BcelPerClausAspectAdder is one that should be skipped since it is related to @AJ ??? Again, I don't know very much about the internal architecture of the weaver magic so I hope this is enough information. I would appreciate it if someone who knows more of the internals could speculate as to why this bug would never pop up on a clean build but only on incremental builds? Also it's not on all incremental builds and I haven't been able to isolate what kind of changes or compiles it triggers this, although it seems that once I got the exception once, I keep getting it on every build until I do a clean. java.lang.NullPointerException at org.aspectj.weaver.ResolvedType.addAndRecurse(ResolvedType.java:288) at org.aspectj.weaver.ResolvedType.getMethodsWithoutIterator(ResolvedType.java:257) at org.aspectj.weaver.ResolvedType.lookupResolvedMember(ResolvedType.java:378) at org.aspectj.weaver.JoinPointSignatureIterator.findSignaturesFromSupertypes(JoinPointSignatureIterator.java:178) at org.aspectj.weaver.JoinPointSignatureIterator.hasNext(JoinPointSignatureIterator.java:69) at org.aspectj.weaver.patterns.SignaturePattern.matches(SignaturePattern.java:287) at org.aspectj.weaver.patterns.KindedPointcut.matchInternal(KindedPointcut.java:103) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144) at org.aspectj.weaver.patterns.AndPointcut.matchInternal(AndPointcut.java:51) at org.aspectj.weaver.patterns.Pointcut.match(Pointcut.java:144) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:64) at org.aspectj.weaver.Advice.match(Advice.java:109) at org.aspectj.weaver.bcel.BcelAdvice.match(BcelAdvice.java:104) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:2210) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:1752) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:479) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1574) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1525) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1305) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1127) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:321) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:192) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:269) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java</file><file>tests/multiIncremental/PR141956/base/A.java</file><file>tests/multiIncremental/PR141956/base/C.java</file><file>tests/multiIncremental/PR141956/inc1/C.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file><file>weaver/src/org/aspectj/weaver/ResolvedType.java</file></fixedFiles></bug><bug commit="9ffc63b" fixdate="1147770000" id="135068" opendate="1144250000" status="resolved fixed"><buginformation><summary>135068 VerifyError with LTW and @AJ style aspects</summary><description>I get "VerifyError: Incompatible object argument for function call" error when using LTW with @Aspect stype aspects. Interestingly enough, LTW works as expected with equivalent .aj style aspect. Compile time weaving works with both aspect styles. Tested on Linux with AspectJ 1.5.0, 1.5.1 and DEVELOPMENT-20060404163823 and SUN 1.5.0_06 and IBM 1.5.0SR1 JVMs. I will attach example project shortly.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java</file><file>tests/bugs152/pr135068/A.java</file><file>tests/bugs152/pr135068/Ajava.java</file><file>tests/bugs152/pr135068/Ajava2.java</file><file>tests/bugs152/pr135068/C.java</file><file>tests/bugs152/pr135068/C2.java</file><file>tests/bugs152/pr135068/t/Ajava.java</file><file>tests/bugs152/pr135068/t/Ajava2.java</file><file>tests/bugs152/pr135068/t/C.java</file><file>tests/bugs152/pr135068/t/C2.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java</file></fixedFiles></bug><bug commit="3fa4d24" fixdate="1147450000" id="133117" opendate="1143190000" status="resolved fixed"><buginformation><summary>133117 Lots of warnings with noGuardForLazyTjp</summary><description>When the noGuardForLazyTjp compiler option is set to warning or error and a piece of advice causes this warning to show up, you get one warning for every join point matched by the advice. I think just one would probably be enough...</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file><file>weaver/src/org/aspectj/weaver/Lint.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file></fixedFiles></bug><bug commit="cb5dfe7" fixdate="1146670000" id="135780" opendate="1144640000" status="resolved fixed"><buginformation><summary>135780 Java 1.2 dependency in aspectjrt.jar bug with fix</summary><description /></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java</file></fixedFiles></bug><bug commit="c667bcb" fixdate="1146070000" id="138286" opendate="1145920000" status="resolved fixed"><buginformation><summary>138286 perthis() causes ClassCastException</summary><description>When using perthis() with an aspect, I see the following Internal Compiler AJDT 1.3.1 / AspectJ 1.5.1a Build 20060406092046 Eclipse 3.1.2, Windows XP, JDK 1.5 Error: java.lang.ClassCastException at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41) at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.visit(PerThisOrTargetPointcutVisitor.java:108) at org.aspectj.weaver.patterns.AndPointcut.accept(AndPointcut.java:119) at org.aspectj.weaver.patterns.PerThisOrTargetPointcutVisitor.getPerTypePointcut(PerThisOrTargetPointcutVisitor.java:41) at org.aspectj.weaver.PerObjectInterfaceTypeMunger.getTestTypePattern(PerObjectInterfaceTypeMunger.java:64) at org.aspectj.weaver.PerObjectInterfaceTypeMunger.matches(PerObjectInterfaceTypeMunger.java:85) at org.aspectj.weaver.ConcreteTypeMunger.matches(ConcreteTypeMunger.java:65) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:508) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1089) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:278) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:168) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) trouble in: public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting extends java.lang.Object: public void &lt;init&gt;(): ALOAD_0 // Lorg/apache/tapestry/internal/aspects/AbstractClassTargetting; this (line 10) INVOKESPECIAL java.lang.Object.&lt;init&gt; ()V initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) | ALOAD_0 | INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class; | LDC org.apache.tapestry.internal.annotations.Synchronized | INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z | IFEQ L0 | ALOAD_0 | INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) | | L0: ALOAD_0 | | INVOKEVIRTUAL java.lang.Object.getClass ()Ljava/lang/Class; | | LDC org.apache.tapestry.internal.annotations.Synchronized | | INVOKEVIRTUAL java.lang.Class.isAnnotationPresent (Ljava/lang/Class;)Z | | IFEQ L1 | | ALOAD_0 | | INVOKESTATIC org.apache.tapestry.internal.aspects.InternalSynchronization.ajc$perObjectBind (Ljava/lang/Object;)V | | L1: RETURN | constructor-execution(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) initialization(void org.apache.tapestry.internal.aspects.AbstractClassTargetting.&lt;init&gt;()) end public void &lt;init&gt;() abstract void ajc$pointcut$$targetClasses$274() org.aspectj.weaver.MethodDeclarationLineNumber: 16:628 ; end public abstract class org.apache.tapestry.internal.aspects.AbstractClassTargetting when weaving type org.apache.tapestry.internal.aspects.AbstractClassTargetting when weaving aspects when weaving when batch building BuildConfig[C:\workspace\.metadata\.plugins\org.eclipse.ajdt.core\tapestry5.generated.lst] #Files=70 I'll attach the corresponding files.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java</file></fixedFiles></bug><bug commit="99882cb" fixdate="1146040000" id="138540" opendate="1146010000" status="resolved fixed"><buginformation><summary>138540 Patch to add support for -Xset: options</summary><description>I needed to add X="set:activateLightweightDelegates=false to my ant build configuration, to troubleshoot the out of memory permgen condition. However, the ant task support doesn't currently support adding the new -Xset style options Andy added. Here is a small patch to pass any -Xset: options through, that worked for me.</description></buginformation><fixedFiles><file>taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java</file></fixedFiles></bug><bug commit="d1a252e" fixdate="1145360000" id="136665" opendate="1144940000" status="resolved fixed"><buginformation><summary>136665 Bug: ajc fails on missing classpath entries with fix</summary><description>[iajc] error at (no source information available) [iajc] File.aj:0::0 Internal compiler error [iajc] org.aspectj.weaver.BCException: Can't open archive: missingjar [iajc] when resolving types defined in compilation unit File.aj [iajc] when processing compilation unit File.aj [iajc] when batch building BuildConfig[null] #Files=14 [iajc] [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO pen(ClassPathManager.java:258) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl assPathManager.java:225) [iajc] at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage r.java:92) [iajc] at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j ava:287) [iajc] at org.aspectj.weaver.World.resolveToReferenceType(World.java:33 5) [iajc] at org.aspectj.weaver.World.resolve(World.java:251) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld (WildTypePattern.java:716) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr omFullyQualifiedTypeName(WildTypePattern.java:690) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W ildTypePattern.java:623) [iajc] at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings( SignaturePattern.java:82) [iajc] at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki ndedPointcut.java:259) [iajc] at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo intcut.java:74) [iajc] at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19 4) [iajc] at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin ishResolveTypes(PointcutDesignator.java:84) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso lveStatements(AdviceDeclaration.java:118) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet hodDeclaration.resolve(AbstractMethodDeclaration.java:400) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1088) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso lve(AspectDeclaration.java:116) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1137) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation UnitDeclaration.resolve(CompilationUnitDeclaration.java:305) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces s(Compiler.java:514) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil e(Compiler.java:329) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform Compilation(AjBuildManager.java:845) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:241) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu ild(AjBuildManager.java:161) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1 12) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java: 60) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:356) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:246) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas k.java:1262) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1 056) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386) [iajc] at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j ava:106) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.Project.executeTargets(Project.java:1062 ) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:673) [iajc] at org.apache.tools.ant.Main.startAnt(Main.java:188) [iajc] at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196) [iajc] at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55) [iajc] Caused by: java.util.zip.ZipException: error in opening zip file [iajc] java.util.zip.ZipException: error in opening zip file [iajc] at java.util.zip.ZipFile.open(Native Method) [iajc] at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:111) [iajc] at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:127) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.ensureO pen(ClassPathManager.java:252) [iajc] at org.aspectj.weaver.bcel.ClassPathManager$ZipFileEntry.find(Cl assPathManager.java:225) [iajc] at org.aspectj.weaver.bcel.ClassPathManager.find(ClassPathManage r.java:92) [iajc] at org.aspectj.weaver.bcel.BcelWorld.resolveDelegate(BcelWorld.j ava:287) [iajc] at org.aspectj.weaver.World.resolveToReferenceType(World.java:33 5) [iajc] at org.aspectj.weaver.World.resolve(World.java:251) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.lookupTypeInWorld (WildTypePattern.java:716) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindingsFr omFullyQualifiedTypeName(WildTypePattern.java:690) [iajc] at org.aspectj.weaver.patterns.WildTypePattern.resolveBindings(W ildTypePattern.java:623) [iajc] at org.aspectj.weaver.patterns.SignaturePattern.resolveBindings( SignaturePattern.java:82) [iajc] at org.aspectj.weaver.patterns.KindedPointcut.resolveBindings(Ki ndedPointcut.java:259) [iajc] at org.aspectj.weaver.patterns.AndPointcut.resolveBindings(AndPo intcut.java:74) [iajc] at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:19 4) [iajc] at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.fin ishResolveTypes(PointcutDesignator.java:84) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.reso lveStatements(AdviceDeclaration.java:118) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMet hodDeclaration.resolve(AbstractMethodDeclaration.java:400) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1088) [iajc] at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.reso lve(AspectDeclaration.java:116) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclara tion.resolve(TypeDeclaration.java:1137) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.ast.Compilation UnitDeclaration.resolve(CompilationUnitDeclaration.java:305) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.proces s(Compiler.java:514) [iajc] at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compil e(Compiler.java:329) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.perform Compilation(AjBuildManager.java:845) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:241) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBu ild(AjBuildManager.java:161) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:1 12) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java: 60) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:356) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:246) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.executeInSameVM(AjcTas k.java:1262) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute(AjcTask.java:1 056) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.taskdefs.Ant.execute(Ant.java:386) [iajc] at org.apache.tools.ant.taskdefs.CallTarget.execute(CallTarget.j ava:106) [iajc] at org.apache.tools.ant.UnknownElement.execute(UnknownElement.ja va:275) [iajc] at org.apache.tools.ant.Task.perform(Task.java:364) [iajc] at org.apache.tools.ant.Target.execute(Target.java:341) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:369) [iajc] at org.apache.tools.ant.Project.executeTarget(Project.java:1214) [iajc] at org.apache.tools.ant.Project.executeTargets(Project.java:1062 ) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:673) [iajc] at org.apache.tools.ant.Main.startAnt(Main.java:188) [iajc] at org.apache.tools.ant.launch.Launcher.run(Launcher.java:196) [iajc] at org.apache.tools.ant.launch.Launcher.main(Launcher.java:55) [iajc] abort ABORT -- (BCException) Can't open archive: wissing.jar [iajc] when resolving types defined in compilation unit File.aj [iajc] when processing compilation unit File.aj [iajc] when batch building BuildConfig[null] #Files=14</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java</file></fixedFiles></bug><bug commit="1a6f695" fixdate="1144320000" id="135001" opendate="1144240000" status="resolved fixed"><buginformation><summary>135001 NPE at at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline</summary><description>java.lang.NullPointerException at org.aspectj.weaver.bcel.BcelShadow.weaveAroundInline(BcelShadow.java:2109) at org.aspectj.weaver.bcel.BcelAdvice.implementOn(BcelAdvice.java:232) at org.aspectj.weaver.Shadow.implementMungers(Shadow.java:639) at org.aspectj.weaver.Shadow.implement(Shadow.java:456) at org.aspectj.weaver.bcel.BcelClassWeaver.implement(BcelClassWeaver.java:2236) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:491) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:109) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1560) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1511) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1291) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1113) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:862) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:242) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191)</description></buginformation><fixedFiles><file>tests/bugs152/pr135001/AbstractAspect.java</file><file>tests/bugs152/pr135001/ConcreteAspect.java</file><file>tests/bugs152/pr135001/Foo.java</file><file>tests/src/org/aspectj/systemtest/AllTests15.java</file><file>tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java</file><file>tests/src/org/aspectj/systemtest/ajc152/AllTestsAspectJ152.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWorld.java</file><file>weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java</file></fixedFiles></bug><bug commit="94d8b82" fixdate="1144320000" id="134541" opendate="1144080000" status="resolved fixed"><buginformation><summary>134541 adviceDidNotMatch's line number doesn't keep up with line number of advice</summary><description>When advice doesn't match in a 1.5.0 enabled project, there is an adviceDidNotMatch warning against the line number of the advice. If you insert a line before this advice and save then the warning stays associated with the original line and not the new one. Full building puts the warning against the new line. This is a regression and didn't happen in AJ 1.5.0.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembers.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java</file></fixedFiles></bug><bug commit="41f1f3a" fixdate="1143530000" id="130837" opendate="1141780000" status="resolved fixed"><buginformation><summary>130837 Exception while trying to edit Annotation based Aspect Class (normal Java class)</summary><description>java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.buildFormalAdviceBindingsFrom(ValidateAtAspectJAnnotationsVisitor.java:417) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.resolveAndSetPointcut(ValidateAtAspectJAnnotationsVisitor.java:364) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.validateAdvice(ValidateAtAspectJAnnotationsVisitor.java:336) at org.aspectj.ajdt.internal.compiler.ast.ValidateAtAspectJAnnotationsVisitor.visit(ValidateAtAspectJAnnotationsVisitor.java:186) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse(MethodDeclaration.java:185) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1195) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:339) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.beforeAnalysing(AjCompilerAdapter.java:154) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$before$org_aspectj_ajdt_internal_compiler_CompilerAdapter$7$db78446d(CompilerAdapter.aj:101) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:517) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:824) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:234) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:189) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:164) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java</file></fixedFiles></bug><bug commit="c9a60e5" fixdate="1143470000" id="133307" opendate="1143430000" status="resolved fixed"><buginformation><summary>133307 declare parents implementing generic interface referencing same type</summary><description>I have the following construct: public interface TestIF&lt;T extends TestIF&gt; {} public class TestClass {} public aspect TestAspect { declare parents: TestClass implements TestIF&lt;TestClass&gt;; } The later aspect does not compile, although public class TestClass implements TestIF&lt;TestClass&gt; { } is a valid class.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java</file><file>weaver/src/org/aspectj/weaver/patterns/IVerificationRequired.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file></fixedFiles></bug><bug commit="2fb86fe" fixdate="1143200000" id="132926" opendate="1143080000" status="resolved fixed"><buginformation><summary>132926 Compiler crashes processing annotations</summary><description>Just upgraded to latest AJDT (Version: 1.3.1, Build id: 20060322082516 AspectJ version: 1.5.1.20060320075953) and the compiler crashed while rebulding the project (which used to work fine using using the March 16th version). Retrying with 'clean' build produced the same crash. java.lang.NullPointerException at org.aspectj.weaver.AnnotationX.ensureAtTargetInitialized(AnnotationX.java:158) at org.aspectj.weaver.AnnotationX.specifiesTarget(AnnotationX.java:98) at org.aspectj.weaver.bcel.BcelWeaver.verifyTargetIsOK(BcelWeaver.java:1450) at org.aspectj.weaver.bcel.BcelWeaver.applyDeclareAtType(BcelWeaver.java:1417) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentTypeMungers(BcelWeaver.java:1366) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1223) at org.aspectj.weaver.bcel.BcelWeaver.weaveParentsFor(BcelWeaver.java:1211) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1058) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:311) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:183) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspectj_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:845) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:241) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:161) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) NullPointerException thrown: null</description></buginformation><fixedFiles><file>tests/bugs151/Deca/DecA.java</file><file>tests/bugs151/pr132926/AffectedType.java</file><file>tests/bugs151/pr132926/InputAnnotation.java</file><file>tests/bugs151/pr132926/InputAnnotation2.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/AnnotationX.java</file></fixedFiles></bug><bug commit="9dca72e" fixdate="1142610000" id="132130" opendate="1142510000" status="resolved fixed"><buginformation><summary>132130 Missing relationship for declare @method when annotating a co-located method</summary><description>For this program (when all entered into *one* file) I don't see a marker from the declare to the annotated method. If the annotated method is in another file, I do... (not sure if fields/ctors/types are also a problem..) public aspect basic { declare @method: * debit(..): @Secured(role="supervisor"); } class BankAccount { public void debit(long accId,long amount) { } } @interface Secured { String role(); }</description></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java</file><file>ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file><file>asm/src/org/aspectj/asm/internal/ProgramElement.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file></fixedFiles></bug><bug commit="e2703cf" fixdate="1142520000" id="131932" opendate="1142430000" status="resolved fixed"><buginformation><summary>131932 structure model bug: generic method ITD</summary><description>import java.util.List; public aspect Slide74 { public X Bar&lt;X&gt;.getFirst() { return lts.get(0); } static class Bar&lt;T&gt; { List&lt;T&gt; lts; } } in AJDT, this program incorrectly shows the relationship from the TYPE to the Bar class rather than from the ITD to the Bar class.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java</file></fixedFiles></bug><bug commit="f2cd94f" fixdate="1142510000" id="131933" opendate="1142430000" status="resolved fixed"><buginformation><summary>131933 grotty ClassCastException on referring to pointcut in generic type</summary><description>import java.util.List; public aspect Slide71 { before(): GenericType&lt;String&gt;.foo() {} before(): GenericType&lt;MyList&gt;.foo() {} //before(): GenericType.foo() {} } class GenericType&lt;T&gt; { public pointcut foo(): execution(* T.*(..)); } that programs gives: (because MyList is not a known type) java.lang.ClassCastException at org.aspectj.weaver.patterns.TypePattern.resolveExactType(TypePattern.java:193) at org.aspectj.weaver.patterns.ReferencePointcut.resolveBindings(ReferencePointcut.java:130) at org.aspectj.weaver.patterns.Pointcut.resolve(Pointcut.java:194) at org.aspectj.ajdt.internal.compiler.ast.PointcutDesignator.finishResolveTypes(PointcutDesignator.java:84) at org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration.resolveStatements(AdviceDeclaration.java:118) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration.resolve(AbstractMethodDeclaration.java:400) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1088) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:116) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1137) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.resolve(CompilationUnitDeclaration.java:305) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.process(Compiler.java:514) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:329) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:843) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:268) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:170) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) ClassCastException thrown: org.aspectj.weaver.patterns.WildTypePattern</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file></fixedFiles></bug><bug commit="b3cd01d" fixdate="1142430000" id="131505" opendate="1142250000" status="resolved fixed"><buginformation><summary>131505 Generated aop.xml files contain aspects for all the projects ever built</summary><description>Using the -outxml option in AJDT the generated aop.xml files are not correct after the first build and contain all the aspects that have ever been built (including those in different projects and duplicates if an aspect has been built twice). It seems that there is a global list of aspects (aspectNames in AjBuildManager) that is never cleared.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java</file><file>tests/multiIncremental/PR131505/base/C.java</file><file>tests/multiIncremental/PR131505/inc2/C.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file></fixedFiles></bug><bug commit="b225911" fixdate="1141580000" id="130300" opendate="1141390000" status="verified fixed"><buginformation><summary>130300 Remove, hide or obfuscate -XnoWeave</summary><description>This option is redundant apart from use in AspectJ development and maintenance. It is confusing to users and is a source new problems for LTW.</description></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java</file><file>taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java</file><file>taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java</file><file>testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java</file><file>tests/src/org/aspectj/systemtest/inpath/InPathTests.java</file></fixedFiles></bug><bug commit="3fa1bdd" fixdate="1140540000" id="122742" opendate="1136460000" status="resolved fixed"><buginformation><summary>122742 [@AspectJ] VerifyError with @AfterThrowing/@AfterReturning and extra JoinPoint argument</summary><description>If an @AspectJ aspect advises itself using after throwing advice that itself throws an exception running the resulting program causes a VerifyError: java.lang.VerifyError: (class: A, method: stop signature: ()V) catch_type not a subclass of Throwable at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2365) at java.lang.Class.getMethod0(Class.java:2611) at java.lang.Class.getMethod(Class.java:1579) at org.aspectj.tools.ajc.AjcTestCase.run(AjcTestCase.java:608) at org.aspectj.testing.RunSpec.execute(RunSpec.java:56) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc150.Ajc150Tests.testError(Ajc150Tests.java:877) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description></buginformation><fixedFiles><file>tests/bugs151/pr122742/AfterReturningTest.java</file><file>tests/bugs151/pr122742/AfterThrowingTest.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/Advice.java</file></fixedFiles></bug><bug commit="89d66dc" fixdate="1140540000" id="128618" opendate="1140440000" status="resolved fixed"><buginformation><summary>128618 [incremental] XLint warnings in the wrong place with incremental compilation</summary><description>The zip file I am about to attach contains two AspectJ project, one depending on the other. If you make a small change to MainClass.java in 'Test Project' and save you will see a strange warning in that class - "advice defined in ras.FFDC has not been applied [Xlint:adviceDidNotMatch]". If you do a full build the warning goes away. Note that the error would be on line 36 if there were 36 lines in the class, which relates to a line in the FFDC aspect that contains advice.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java</file><file>tests/multiIncremental/PR128618_2/base/mainpackage/MainClass.java</file><file>tests/multiIncremental/PR128618_2/inc1/mainpackage/MainClass.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file></fixedFiles></bug><bug commit="ba42a09" fixdate="1140540000" id="128237" opendate="1140110000" status="resolved fixed"><buginformation><summary>128237 [@AspectJ] NPE on @AJ code with pointcut which contains logical OR operation.</summary><description /></buginformation><fixedFiles><file>tests/bugs151/pr128237.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file></fixedFiles></bug><bug commit="7a2087e" fixdate="1140540000" id="128744" opendate="1140500000" status="resolved fixed"><buginformation><summary>128744 LTW doesn't work using JRE1.4 in Eclipse</summary><description>LTW doesn't work using JRE1.4 in Eclipse now I want to support JRE1.4 when LTW. I defined a aop.xml file in application META-INF path, it works fine using JRE1.4 in command-line, aop.xml file is used when LTW, the command as below: "D:\work\BTM\eclipse 3.1.1\eclipse-SDK-3.1.1-win32\eclipse-1.4.2\jre\bin\java" -classpath "C:\aspectj1.5\lib\aspectjweaver.jar" "-Djava.system.class.loader=org.aspectj.weaver.loadtime.WeavingURLClassLoader" "-Daj.class.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest;C:\aspectj1.5\doc\examples\armtest\jar\btm-deps-e3.1.jar;C:\aspectj1.5\doc\examples\armtest\jar\btm-rt.jar" Hello but it doesn't work in Eclipse, I added upper command to VM arguments, it can't find aop.xml, because if I changed aop.xml to be wrong, there is no any error when execute the application in Eclipse , but there will be error when execute it in command-line, based on this point, I think that aop.xml didn't be used in Eclipse, I also tried to add "-Daj.aspect.path=D:\work\BTM\eclipse 3.1.1\jre1.4.2\myTest", but it is still. so I want to confirm if AspectJ only supports command-line for JRE1.4? doesn't support Eclipse for JRE1.4? BTW, my Eclipse env: eclipse 3.1.1 + ajdt_1.3_for_eclipse_3.1 + Sun JDK 1.4.2. I also tried to use eclipse 3.1.2, but this problem is still existed.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java</file><file>tests/bugs151/pr128744/Hello.java</file><file>tests/bugs151/pr128744/World.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file></fixedFiles></bug><bug commit="f95d2c9" fixdate="1140460000" id="128699" opendate="1140460000" status="resolved fixed"><buginformation><summary>128699 Incorrect error on "declare" statements</summary><description>The error associated with the declare construct is incorrect. The current message is: "expected one of error, warning, parents, soft, dominates" dominates should be changed to "precendence" and new annotation related declararions should be mentioned. Here is a suggestion: "expected one of error, warning, parents, soft, precedence, @type, @method, @constructor, @field"</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/patterns/PatternParser.java</file></fixedFiles></bug><bug commit="e874581" fixdate="1140110000" id="122370" opendate="1135920000" status="resolved fixed"><buginformation><summary>122370 [@AspectJ] @DeclareParents/declare parents not equivalent</summary><description>Adding a setter to the Moody example makes it clear that the annotation style (@DeclareParents) results in different behavior than the classic (declare parents) style. Calling the setter in a "declare parents"-advised object behaves as one would expect. However, calling the setter with a "@DeclareParents"-advised object has no effect -- that is, you can call the setter (and see that it's been called) and immediately call the getter, only to find that the value didn't change. The following examples (all in "package moody;") illustrate: public enum Mood { HAPPY, JOLLY } Classic style: ------------- public aspect ClassicMoodIndicator { public interface Moody { Mood getMood(); void setMood(Mood mood); } private Mood Moody.mood = Mood.HAPPY; public Mood Moody.getMood() { return mood; } public void Moody.setMood(Mood mood) { this.mood = mood; } declare parents : moody.ClassicMoodImplementor implements Moody; } public class ClassicMoodImplementor { } Annotation style: ---------------- import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.DeclareParents; @Aspect public class AnnotationMoodIndicator { public interface Moody { Mood getMood(); void setMood(Mood mood); } public static class MoodyImpl implements Moody { private Mood mood = Mood.HAPPY; public Mood getMood() { return mood; } public void setMood(Mood mood) { this.mood = mood; } } @DeclareParents(value="moody.AnnotationMoodImplementor",defaultImpl=MoodyImpl.class) private Moody implementedInterface; } public class AnnotationMoodImplementor { } JUnit TestCase: -------------- import junit.framework.TestCase; public class MoodTester extends TestCase { public MoodTester(String name) { super(name); } public void testClassic() { ClassicMoodImplementor cmi0 = new ClassicMoodImplementor(); ClassicMoodImplementor cmi1 = new ClassicMoodImplementor(); assertEquals("cmi0 should be HAPPY", Mood.HAPPY, cmi0.getMood()); cmi1.setMood(Mood.JOLLY); assertEquals("cmi1 should be JOLLY", Mood.JOLLY, cmi1.getMood()); assertEquals("cmi0 should be *still* be HAPPY", Mood.HAPPY, cmi0.getMood()); } public void testAnnotation() { AnnotationMoodImplementor ami0 = new AnnotationMoodImplementor(); AnnotationMoodImplementor ami1 = new AnnotationMoodImplementor(); assertEquals("ami0 should be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood()); ((AnnotationMoodIndicator.Moody) ami1).setMood(Mood.JOLLY); assertEquals("ami1 should be JOLLY", Mood.JOLLY, ((AnnotationMoodIndicator.Moody) ami1).getMood()); assertEquals("ami0 should be *still* be HAPPY", Mood.HAPPY, ((AnnotationMoodIndicator.Moody) ami0).getMood()); } } Result: ------ The test run is as follows: ..F Time: 0.021 There was 1 failure: 1) testAnnotation(moody.MoodTester)junit.framework.AssertionFailedError: ami1 should be JOLLY expected:&lt;JOLLY&gt; but was:&lt;HAPPY&gt; at moody.MoodTester.testAnnotation(MoodTester.java:27) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) at moody.MoodTester.main(MoodTester.java:7) FAILURES!!! Tests run: 2, Failures: 1, Errors: 0 For classic, you can see that cmi1.setMood was successful and cmi0/cmi1 are decoupled (that is, calling setMood on cmi1 has no impact on cmi0). The annotation style, however, fails because ami1.setMood appears to have done nothing. The result should have been that ami1 is JOLLY and ami0 HAPPY (I include the second assert because both ami0 &amp; ami1 ended up JOLLY in RC1). The current behavior makes @DeclareParents unusable for retaining field state (near as I can tell, it retains state throughout the method invocation, but not beyond it, like it is creating and discarding a backing object with each method invocation).</description></buginformation><fixedFiles><file>tests/bugs151/pr122370/moody/AnnotationMoodImplementor.java</file><file>tests/bugs151/pr122370/moody/AnnotationMoodIndicator.java</file><file>tests/bugs151/pr122370/moody/MainClass.java</file><file>tests/bugs151/pr122370/moody/Mood.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="d4219e1" fixdate="1140080000" id="121616" opendate="1135110000" status="resolved fixed"><buginformation><summary>121616 [@AspectJ]Lacking import for JoinPoint crahes the compiler</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java</file><file>tests/bugs151/pr121616.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file></fixedFiles></bug><bug commit="f743fb2" fixdate="1139570000" id="120356" opendate="1134390000" status="resolved fixed"><buginformation><summary>120356 @AJ decl err/warn does not show cross structure view</summary><description>Perhaps an issue in the ASM struct for DEOW since cross struct. is empty in AJDT , despite error / warning gutter and message is ok.</description></buginformation><fixedFiles><file>tests/bugs151/pr120356/A.java</file><file>tests/bugs151/pr120356/C.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java</file></fixedFiles></bug><bug commit="d856e4f" fixdate="1139560000" id="123212" opendate="1136880000" status="resolved fixed"><buginformation><summary>123212 Skip subversion resources when copying files from input to output folders</summary><description>Exception when compile a project under svn. java.io.FileNotFoundException at java.io.FileOutputStream.open(Native Method) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:179) at java.io.FileOutputStream.&lt;init&gt;(FileOutputStream.java:131) at org.aspectj.util.FileUtil.makeOutputStream(FileUtil.java:1258) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:466) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromFile(AjBuildManager.java:444) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:386) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:298) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) FileNotFoundException thrown: /home/chomats/Fede/svn/fede-repos/Tool.Product.ProductServer/classes/.svn/format (Permission non accordee)</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file></fixedFiles></bug><bug commit="551b446" fixdate="1138370000" id="121395" opendate="1134990000" status="resolved fixed"><buginformation><summary>121395 invalid aspectj path throws filenotfoundexception</summary><description>An invalid aspectj path (missing jar file) throws an filenotfoundexception: java.io.FileNotFoundException at java.io.FileInputStream.open(Native Method) at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:106) at org.aspectj.weaver.bcel.BcelWeaver.addAspectsFromJarFile(BcelWeaver.java:202) at org.aspectj.weaver.bcel.BcelWeaver.addLibraryJarFile(BcelWeaver.java:192) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.initBcelWorld(AjBuildManager.java:623) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:209) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) FileNotFoundException thrown: /Users/frankstolle/Documents/workspace/lib_aspects/deploy/lib_aspects.jar (No such file or directory) should generate an problem entry in the problems-list.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file></fixedFiles></bug><bug commit="efb20c5" fixdate="1138210000" id="125101" opendate="1138150000" status="resolved fixed"><buginformation><summary>125101 StackOverFlow in ReferenceType.isAssignableFrom()</summary><description>Hi. I am weaving two aspects into a jar file "jar-to-jar". ajc 1.5.0 gives me a huge error message (see attachement). Would be great if I could get any recommendations on this. Thanks! Eric</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/BcelWorld.java</file></fixedFiles></bug><bug commit="a4bd19d" fixdate="1138120000" id="124999" opendate="1138110000" status="resolved fixed"><buginformation><summary>124999 [generics] Incorrect call to generic inherited method in around advice</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file></fixedFiles></bug><bug commit="28f8c69" fixdate="1138030000" id="124654" opendate="1137770000" status="resolved fixed"><buginformation><summary>124654 Capture method annotation in generic aspect does not compile</summary><description /></buginformation><fixedFiles><file>tests/bugs151/pr124654/GenericAnnotation.java</file><file>tests/bugs151/pr124654/TestSubAspect.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file></fixedFiles></bug><bug commit="01a8b2e" fixdate="1138030000" id="124808" opendate="1137950000" status="resolved fixed"><buginformation><summary>124808 [generics] detecting field-get of field of parameterized type.</summary><description>Hi, Here is the second generics issue: Java code: ========== public class Test&lt;T extends Integer&gt; { Set&lt;T&gt; ints = new HashSet&lt;T&gt;(); public Set&lt;T&gt; foo() { return ints; } public static void main(String[] args) { Test&lt;Integer&gt; t = new Test&lt;Integer&gt;(); Set&lt;Integer&gt; ints = t.foo(); } } Aspect: ======= public privileged aspect TestAspect { pointcut gettingMemberCollection(Test t) : target(t) &amp;&amp; get(!public Set&lt;Number+&gt; com.mprv.secsph.*.*) &amp;&amp; !within(TestAspect); after (Test test) : gettingMemberCollection(test) { System.out.println("GO Aspects!"); } } Compiler output: ================ warning at after (Test test) : gettingMemberCollection(test) { ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ /root/IdeaProjects/aspectsTest/src/com/mprv/secsph/TestAspect.aj:19:0::0 advice defined in com.mprv.secsph.TestAspect has not been applied [Xlint:adviceDidNotMatch] I would expect "gettingMemberCollection" to catch access to "ints" member of "Test" ... Thanks a lot! Misha.</description></buginformation><fixedFiles><file>tests/bugs151/pr124808/Test.java</file><file>tests/bugs151/pr124808/TestAspect.java</file><file>tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file></fixedFiles></bug><bug commit="ab2f89b" fixdate="1137510000" id="123612" opendate="1137080000" status="resolved fixed"><buginformation><summary>123612 ArrayIndexOutOfBoundsException with incremental and declare @type</summary><description>Given the following code: ------------------------------------------------- public aspect A { declare @type : C : @MyAnnotation; } @interface MyAnnotation { } class C { } ------------------------------------------------- if you comment out the declare @type statement and do an incremental build, then the following ArrayIndexOutOfBoundsException occurs: java.lang.ArrayIndexOutOfBoundsException: 0 at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.doDeclareAnnotations(AjLookupEnvironment.java:754) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveInterTypeDeclarations(AjLookupEnvironment.java:571) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.weaveIntertypes(AjLookupEnvironment.java:357) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:209) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) This is against the latest code in HEAD.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java</file></fixedFiles></bug><bug commit="d69ce9a" fixdate="1136810000" id="122728" opendate="1136450000" status="resolved fixed"><buginformation><summary>122728 ajdoc crashes</summary><description /></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java</file><file>ajdoc/testdata/pr122728/src/pack/ClassWithInnerEnum.java</file><file>ajdoc/testdata/pr122728/src/pack/EnumWithMethods.java</file><file>ajdoc/testdata/pr122728/src/pack/MyEnum.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/EnumTest.java</file></fixedFiles></bug><bug commit="bbdd496" fixdate="1135160000" id="58520" opendate="1081960000" status="resolved fixed"><buginformation><summary>58520 ajdoc doesn't navigate to target details in some cases</summary><description>When a file is advised, javadoc uses the following naming convention for setting its "A NAME": convertCheckedException(java.lang.Throwable) However, ajdoc uses the unqualified name for the argument, resuting in the follwing in-file anchor link: &lt;class-name&gt;.html#convertCheckedException(Throwable) Which fails to navigate to the anchor within the file, although it does always go to the right file.</description></buginformation><fixedFiles><file>ajdoc/testdata/pr119453/src/pack/C.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/FullyQualifiedArgumentTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file></fixedFiles></bug><bug commit="9abfc40" fixdate="1134660000" id="120909" opendate="1134580000" status="resolved fixed"><buginformation><summary>120909 Test failures using IBM Java 5</summary><description>1. ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates() junit.framework.AssertionFailedError: Errors:Couldn't find void java.util.HashMap.onEntry() in the bcel set Couldn't find void java.util.HashMap.onExit() in the bcel set Couldn't find void java.util.HashMap.transfer0(java.util.HashMap$Entry[]) in the bcel set at junit.framework.Assert.fail(Assert.java:47) at junit.framework.Assert.assertTrue(Assert.java:20) at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:278) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:615) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) This failure occures because when we compare BeclWorld with ReflectionWorld we are still picking up the default (Sun) version of HashMap in JRE15_LIB for BCEL. The solution is to create both worlds with the same class loader. 2. Ajc150Tests.testModifierOverrides() junit.framework.AssertionFailedError: Expecting output: execution(void pr119749.C.m()): execMe[@pr119749$Me()] execution(void pr119749.C.m()): execEx But found output: execution(void pr119749.C.m()): execMe[@pr119749.Me()] execution(void pr119749.C.m()): execEx First difference is on line 1 at junit.framework.Assert.fail(Assert.java:47) at org.aspectj.testing.OutputSpec.matchAgainst(OutputSpec.java:58) at org.aspectj.testing.RunSpec.execute(RunSpec.java:61) at org.aspectj.testing.AjcTest.runTest(AjcTest.java:68) at org.aspectj.testing.XMLBasedAjcTestCase.runTest(XMLBasedAjcTestCase.java:111) at org.aspectj.systemtest.ajc150.Ajc150Tests.testModifierOverrides(Ajc150Tests.java:852) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:615) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.extensions.TestDecorator.basicRun(TestDecorator.java:22) at junit.extensions.TestSetup$1.protect(TestSetup.java:19) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.extensions.TestSetup.run(TestSetup.java:23) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196) This failure is due a difference between JDKs in the implementation of toString() for annotations.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java</file><file>weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java</file><file>weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java</file><file>weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java</file></fixedFiles></bug><bug commit="9d32b76" fixdate="1134480000" id="120543" opendate="1134470000" status="resolved fixed"><buginformation><summary>120543 Issue version message during load-time weaving</summary><description>It would be very useful to know exactly which version of the weaver is being used for LTW. An informational message could be issued when each WeavingAdaptor instance is created (it is possible to have multiple versions of AspectJ in a system). This message could be similar to the that issued by "ajc -version".</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="3ac4627" fixdate="1134410000" id="120401" opendate="1134410000" status="resolved fixed"><buginformation><summary>120401 add signature to UnresolvedType.parameterize(..) exception</summary><description>I keep getting UnresolvedType UnsupportedOperationException unhelpful message "resolve this type first," so I'm adding the signature to the message (without permission, hence the bug as notice). throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature); ------------------------------- java.lang.UnsupportedOperationException at org.aspectj.weaver.UnresolvedType.parameterize(UnresolvedType.java:218) at org.aspectj.weaver.patterns.ExactTypePattern.parameterizeWith(ExactTypePattern.java:242) at org.aspectj.weaver.patterns.TypePatternList.parameterizeWith(TypePatternList.java:195) at org.aspectj.weaver.patterns.DeclareParents.parameterizeWith(DeclareParents.java:77) at org.aspectj.weaver.ReferenceType.getDeclares(ReferenceType.java:484) at org.aspectj.weaver.ResolvedType.collectDeclares(ResolvedType.java:523) at org.aspectj.weaver.ResolvedType.collectCrosscuttingMembers(ResolvedType.java:488) at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect(CrosscuttingMembersSet.java:60) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:378) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.addCrosscuttingStructures(AjLookupEnvironment.java:388) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.collectAllITDsAndDeclares(AjLookupEnvironment.java:314) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:168) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:301) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:315) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:811) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:230) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:185) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild(AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:191) UnsupportedOperationException thrown: resolve this type first</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/UnresolvedType.java</file></fixedFiles></bug><bug commit="9edb4b6" fixdate="1134400000" id="120363" opendate="1134400000" status="resolved fixed"><buginformation><summary>120363 LTW weaver include and exclude does not behave correctly</summary><description /></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>tests/java5/ataspectj/ataspectj/Test$$EnhancerByCGLIB$$12345.java</file><file>tests/java5/ataspectj/com/foo/bar/Test$$EnhancerByCGLIB$$12345.java</file><file>tests/java5/ataspectj/com/foo/bar/Test.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java</file></fixedFiles></bug><bug commit="979124d" fixdate="1134380000" id="120351" opendate="1134380000" status="resolved fixed"><buginformation><summary>120351 cflowbelow issue when binding, in @AJ</summary><description /></buginformation><fixedFiles><file>tests/java5/ataspectj/ataspectj/bugs/CflowBelowStackTest.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="5f8d2cd" fixdate="1134120000" id="119451" opendate="1133890000" status="resolved fixed"><buginformation><summary>119451 AJDoc produces incorrect warning for package accessed aspects</summary><description /></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java</file><file>ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file></fixedFiles></bug><bug commit="b52515f" fixdate="1134120000" id="119353" opendate="1133840000" status="resolved fixed"><buginformation><summary>119353 Inconsistent Implementations of ReferenceType.getDeclaredMethods()</summary><description>I am running into a problem in load-time weaving when I use reflection delegates because the weaver is generating an incorrect bridge method when I perform an inter-type declaration on Struts.ActionServlet for the init method. On investigation, the BCEL world is recognizing this as an overriding method, because its version of getDeclaredMethods is returning the declared methods for all ancestor superclasses. However, the reflection world is returning only the declared methods for this one class. It therefore appears that the weaver expects getDeclaredMethods to return all of them (making the name quite misleading). I think previously the method was being implemented inconsistently between 1.5 reflection and &lt;1.5 reflection delegates. But it looks like it needs to be handled consistently to include all superclass methods. However, I dont know what other places (e.g., the MAP) are really expecting getDeclaredMethods and its siblings to behave like Java reflection's version... I started work on adding a getAllDeclaredMethods method to ReferenceType and delegates, as an alternative to provide the weaver the ability to check method overriding as in this case, but it's a little bit involved and I wanted to flag the issue first. Here's a test that fails and illustrates the issue: Index: ReflectionBasedReferenceTypeDelegateTest.java =================================================================== RCS file: /home/technology/org.aspectj/modules/weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java,v retrieving revision 1.5 diff -u -r1.5 ReflectionBasedReferenceTypeDelegateTest.java --- ReflectionBasedReferenceTypeDelegateTest.java 28 Nov 2005 17:44:40 -0000 1.5 +++ ReflectionBasedReferenceTypeDelegateTest.java 6 Dec 2005 04:11:41 -0000 @@ -238,6 +238,18 @@ assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT)); } + public void testCompareSubclassDelegates() { + world.setBehaveInJava5Way(true); + + BcelWorld bcelWorld = new BcelWorld(); + bcelWorld.setBehaveInJava5Way(true); + UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap"); + ReferenceType rawType = (ReferenceType)bcelWorld.resolve(javaUtilHashMap ); + + ReferenceType rawReflectType = (ReferenceType)world.resolve(javaUtilHashMap ); + assertEquals(rawType.getDelegate().getDeclaredMethods().length, rawReflectType.getDelegate().getDeclaredMethods().length); + } + // todo: array of int protected void setUp() throws Exception { This results in: junit.framework.AssertionFailedError: expected:&lt;41&gt; but was:&lt;29&gt; at junit.framework.Assert.fail(Assert.java:47) at junit.framework.Assert.failNotEquals(Assert.java:282) at junit.framework.Assert.assertEquals(Assert.java:64) at junit.framework.Assert.assertEquals(Assert.java:201) at junit.framework.Assert.assertEquals(Assert.java:207) at org.aspectj.weaver.reflect.ReflectionBasedReferenceTypeDelegateTest.testCompareSubclassDelegates(ReflectionBasedReferenceTypeDelegateTest.java:250) at java.lang.reflect.Method.invoke(Native Method) at junit.framework.TestCase.runTest(TestCase.java:154) at junit.framework.TestCase.runBare(TestCase.java:127) at junit.framework.TestResult$1.protect(TestResult.java:106) at junit.framework.TestResult.runProtected(TestResult.java:124) at junit.framework.TestResult.run(TestResult.java:109) at junit.framework.TestCase.run(TestCase.java:118) at junit.framework.TestSuite.runTest(TestSuite.java:208) at junit.framework.TestSuite.run(TestSuite.java:203) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:478) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:344) at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:196)</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java</file><file>weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java</file><file>weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java</file></fixedFiles></bug><bug commit="94159f9" fixdate="1134040000" id="109614" opendate="1126790000" status="resolved fixed"><buginformation><summary>109614 [waiting-on-build] [iajc.task] java.lang.RuntimeException: Ranges must be updated with an enclosing instructionList</summary><description /></buginformation><fixedFiles><file>tests/bugs150/pr109614.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="1e1bbb3" fixdate="1133870000" id="118715" opendate="1133390000" status="resolved fixed"><buginformation><summary>118715 Load Time Weaving wipes out Xlint files if no Xlint values</summary><description>In ClassLoaderWeavingAdaptor if weaverOption.lint is null, then a loaded Xlint properties file gets overwritten by the default Xlint properties. See attached patch to fix this problem.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>testing/newsrc/org/aspectj/testing/OutputSpec.java</file><file>testing/newsrc/org/aspectj/testing/RunSpec.java</file><file>testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java</file><file>tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file><file>weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java</file></fixedFiles></bug><bug commit="a75b7fa" fixdate="1133450000" id="118781" opendate="1133430000" status="resolved fixed"><buginformation><summary>118781 [waiting-on-build]VerifyError in AspectJ</summary><description>I'm fairly new to AspectJ, so this is probably not going to be well explained. I've started working on a project that was working fine. Then I added methods to classes that take a 2-dimensional string array parameter and suddenly I'm getting a VerifyError exception. java.lang.VerifyError: (class: com/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00, method: searchForObligorSummariesByGroup_aroundBody24 signature: (Lcom/drkw/cpds/obligor/facades/version_1_00/ObligorDetailFacade_1_00;[[[Ljava/lang/String;Ljava/lang/String;LjavaA(&amp;#130; at com.drkw.cpds.obligor.facades.version_1_00.obligor.ObligorManager.&lt;clinit&gt;(ObligorManager.java:48) at com.drkw.cpds.obligor.integration.version_1_00.obligor.GetObligorDetailsGroupingTest.testGetObligorDetailsUsingGroups(GetObligorDetailsGroupingTest.java:45) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</description></buginformation><fixedFiles><file>tests/bugs150/pr118781/MyAspect.java</file><file>tests/bugs150/pr118781/MyClass.java</file><file>tests/bugs150/pr118781/MyMain.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/World.java</file></fixedFiles></bug><bug commit="551b9ca" fixdate="1133380000" id="117209" opendate="1132470000" status="resolved fixed"><buginformation><summary>117209 Runtime error - Stack size too large, Bug#69706 related.</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>tests/multiIncremental/pr117209/base/src/Aspect.java</file><file>tests/multiIncremental/pr117209/base/src/Broken.java</file><file>tests/multiIncremental/pr117209/base/src/DefaultInterfaceImplementationRecipe.java</file><file>tests/multiIncremental/pr117209/base/src/MyClass_ch16.java</file><file>tests/multiIncremental/pr117209/base/src/MyInterface_ch16.java</file><file>tests/multiIncremental/pr117209/base/src/P.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java</file><file>tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java</file></fixedFiles></bug><bug commit="11ab99f" fixdate="1132750000" id="117681" opendate="1132740000" status="resolved fixed"><buginformation><summary>117681 VerifyError when using annotations to define inter-type annotation</summary><description>Using Sun JDK1.5.0_04 Audit.java public interface Audit { public String getLastUpdatedBy(); public void setLastUpdatedBy(String un); } AuditImpl.java public class AuditImpl implements Audit { private String lastUpdatedBy; public String getLastUpdatedBy() { return lastUpdatedBy; } public void setLastUpdatedBy(String un) { lastUpdatedBy = un; } } TestAspect.java import org.aspectj.lang.annotation.*; Test.java @Aspect public class TestAspect { @DeclareParents("Test") public static Audit introduced = new AuditImpl(); } public class Test { public static void main(String[] args) { Test t = new Test(); Audit a = (Audit)t; a.setLastUpdatedBy("username"); System.out.println("Username ="+a.getLastUpdatedBy()); } } files.lst Audit.java AuditImpl.java TestAspect.java Test.java Compiled using the following command d:\aspectj1.5\bin\ajc -classpath "d:\aspectj1.5\lib\aspectjrt.jar" -argfi le files.lst -1.5 d:\aspectj1.5\bin\aj5 Test Exception in thread "main" java.lang.VerifyError: (class: Test, method: setLastUpdatedBy signature: (Ljava/lang/String;)V) Incompatible argument to function d:\aspectj1.5\bin\aj5 -noverify Test Username=</description></buginformation><fixedFiles><file>tests/bugs150/pr117681/Audit.java</file><file>tests/bugs150/pr117681/AuditImpl.java</file><file>tests/bugs150/pr117681/MoodIndicator.java</file><file>tests/bugs150/pr117681/Test.java</file><file>tests/bugs150/pr117681/TestAspect.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="a5ac5af" fixdate="1132740000" id="117189" opendate="1132420000" status="resolved fixed"><buginformation><summary>117189 Contribution: reduce overhead when no aspects define</summary><description>This patch to the ClassLoaderWeavingAdaptor adds two optimizations when enabled is false for the adaptor: it immediately returns false for accept and it also avoids the overhead of constructing a weaver or world. It also contains commented out code that was letting me improve performance by loading reflective proxies instead of creating BCEL objects for a resolution loader (which is currently broken since reflective proxies now require a ReflectionWorld...)</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="9ed75a1" fixdate="1132590000" id="115607" opendate="1131530000" status="resolved fixed"><buginformation><summary>115607 Incorrect structure model for simple declare @type program?</summary><description>This program: ---8&lt;----- @interface I {} class Simple {} public aspect C { declare @type: Simple : @I; } ---8&lt;----- (all in a file called C.java, open with the AJ editor) when built shows incorrect gutter markers, it shows a double headed arrow on Simple implying that it annotates itself - rather than something outgoing from the declare statement and something incoming on the Simple type.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java</file><file>tests/bugs150/pr115607.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file></fixedFiles></bug><bug commit="dd9a9b2" fixdate="1132310000" id="116949" opendate="1132270000" status="verified fixed"><buginformation><summary>116949 [waitingOnAJDTdrop]Exception thrown from AspectJ compiler</summary><description>java.lang.ClassCastException at org.aspectj.weaver.bcel.BcelClassWeaver.checkForOverride (BcelClassWeaver.java:607) at org.aspectj.weaver.bcel.BcelClassWeaver.calculateAnyRequiredBridgeMethods (BcelClassWeaver.java:676) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1537) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump(BcelWeaver.java:1485) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify(BcelWeaver.java:1266) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:1088) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:300) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.CompilerAdapter.ajc$afterReturning$org_aspect j_ajdt_internal_compiler_CompilerAdapter$2$f9cc9ca0(CompilerAdapter.aj:70) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile (Compiler.java:367) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:809) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:254) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.incrementalBuild (AjBuildManager.java:163) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:191) trouble in: public class ts.simul.client.AbstractClient$OptionSetter extends ts.util.CmdLineProgram$OptionSetterBase: final ts.simul.client.AbstractClient this$0 private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 public void &lt;init&gt;(ts.simul.client.AbstractClient) org.aspectj.weaver.MethodDeclarationLineNumber: 59:1411 : ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 60) ALOAD_1 PUTFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 59) ALOAD_1 INVOKESPECIAL ts.util.CmdLineProgram$OptionSetterBase.&lt;init&gt; (Lts/util/CmdLineProgram;)V constructor-execution(void ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt; (ts.simul.client.AbstractClient)) | RETURN constructor-execution(void ts.simul.client.AbstractClient$OptionSetter.&lt;init&gt; (ts.simul.client.AbstractClient)) end public void &lt;init&gt;(ts.simul.client.AbstractClient) public boolean setOption_file(String) throws ts.util.IllegalProgramArgumentException org.aspectj.weaver.MethodDeclarationLineNumber: 62:1469 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String)) | ALOAD_1 // java.lang.String optParam (line 65) | method-call(int java.lang.String.length()) | | INVOKEVIRTUAL java.lang.String.length ()I | method-call(int java.lang.String.length()) | IFLE L1 | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 66) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | NEW java.io.File (line 67) | DUP | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | GETFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String)) | | INVOKESPECIAL java.io.File.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void java.io.File.&lt;init&gt;(java.lang.String)) | ASTORE_2 | ALOAD_2 // java.io.File file (line 68) | method-call(boolean java.io.File.exists()) | | INVOKEVIRTUAL java.io.File.exists ()Z | method-call(boolean java.io.File.exists()) | IFNE L0 | NEW ts.util.IllegalProgramArgumentException (line 69) | DUP | NEW java.lang.StringBuilder | DUP | LDC "Cannot find file: [" | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String)) | | INVOKESPECIAL java.lang.StringBuilder.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void java.lang.StringBuilder.&lt;init&gt;(java.lang.String)) | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | GETFIELD ts.simul.client.AbstractClient.fileName Ljava/lang/String; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | | INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | LDC "]" | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | | INVOKEVIRTUAL java.lang.StringBuilder.append (Ljava/lang/String;)Ljava/lang/StringBuilder; | method-call(java.lang.StringBuilder java.lang.StringBuilder.append (java.lang.String)) | method-call(java.lang.String java.lang.StringBuilder.toString()) | | INVOKEVIRTUAL java.lang.StringBuilder.toString () Ljava/lang/String; | method-call(java.lang.String java.lang.StringBuilder.toString()) | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | | INVOKESPECIAL ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | ATHROW | L0: ICONST_1 (line 70) | IRETURN | L1: ICONST_0 (line 73) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_file(java.lang.String)) end public boolean setOption_file(String) throws ts.util.IllegalProgramArgumentException public boolean setOption_class(String) throws ts.util.IllegalProgramArgumentException org.aspectj.weaver.MethodDeclarationLineNumber: 76:1971 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String)) | ALOAD_1 // java.lang.String optParam (line 79) | method-call(int java.lang.String.length()) | | INVOKEVIRTUAL java.lang.String.length ()I | method-call(int java.lang.String.length()) | IFLE L1 | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 80) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.className Ljava/lang/String; | catch ts.simul.SimulationException -&gt; E0 | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 82) | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | GETFIELD ts.simul.client.AbstractClient.className Ljava/lang/String; | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass (java.lang.String)) | | | INVOKESTATIC ts.simul.SceneFactory.getSceneClass (Ljava/lang/String;)Ljava/lang/Class; | | method-call(java.lang.Class ts.simul.SceneFactory.getSceneClass (java.lang.String)) | | PUTFIELD ts.simul.client.AbstractClient.sceneClass Ljava/lang/Class; | | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 83) | | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath()) | | | INVOKESTATIC ts.simul.Architecture.aspectOf () Lts/simul/Architecture; | | | GETSTATIC ts.simul.client.AbstractClient$OptionSetter.ajc$tjp_0 Lorg/aspectj/lang/JoinPoint$StaticPart; | | | INVOKEVIRTUAL ts.simul.Architecture.ajc$before$ts_simul_Architecture$1$ae285a4d (Lorg/aspectj/lang/JoinPoint$StaticPart;)V | | | INVOKEVIRTUAL ts.simul.client.AbstractClient.setBeanInfoSearchPath ()V | | method-call(void ts.simul.client.AbstractClient.setBeanInfoSearchPath()) | | GOTO L0 | catch ts.simul.SimulationException -&gt; E0 | E0: ASTORE_2 (line 85) | NEW ts.util.IllegalProgramArgumentException (line 86) | DUP | ALOAD_2 // ts.simul.SimulationException e | method-call(java.lang.String ts.simul.SimulationException.getMessage()) | | INVOKEVIRTUAL ts.simul.SimulationException.getMessage () Ljava/lang/String; | method-call(java.lang.String ts.simul.SimulationException.getMessage()) | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | | INVOKESPECIAL ts.util.IllegalProgramArgumentException.&lt;init&gt; (Ljava/lang/String;)V | constructor-call(void ts.util.IllegalProgramArgumentException.&lt;init&gt; (java.lang.String)) | ATHROW | L0: ICONST_1 (line 88) | IRETURN | L1: ICONST_0 (line 91) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_class(java.lang.String)) end public boolean setOption_class(String) throws ts.util.IllegalProgramArgumentException public boolean setOption_name(String) org.aspectj.weaver.MethodDeclarationLineNumber: 94:2593 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String)) | ALOAD_0 // ts.simul.client.AbstractClient$OptionSetter this (line 96) | GETFIELD ts.simul.client.AbstractClient$OptionSetter.this$0 Lts/simul/client/AbstractClient; | ALOAD_1 // java.lang.String optParam | PUTFIELD ts.simul.client.AbstractClient.sceneName Ljava/lang/String; | ICONST_1 (line 97) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_name(java.lang.String)) end public boolean setOption_name(String) public boolean setOption_actors(String) org.aspectj.weaver.MethodDeclarationLineNumber: 100:2739 : method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String)) | catch java.lang.NumberFormatException -&gt; E0 | | ALOAD_1 // java.lang.String optParam (line 103) | | method-call(int java.lang.Integer.parseInt(java.lang.String)) | | | INVOKESTATIC java.lang.Integer.parseInt (Ljava/lang/String;) I | | method-call(int java.lang.Integer.parseInt(java.lang.String)) | | ISTORE_2 | | GOTO L0 | catch java.lang.NumberFormatException -&gt; E0 | E0: ASTORE_2 // int n (line 105) | ICONST_0 (line 106) | IRETURN | L0: ICONST_1 (line 108) | IRETURN method-execution(boolean ts.simul.client.AbstractClient$OptionSetter.setOption_actors(java.lang.String)) end public boolean setOption_actors(String) end public class ts.simul.client.AbstractClient$OptionSetter when weaving type ts.simul.client.AbstractClient$OptionSetter when weaving classes when weaving when incrementally building BuildConfig [c:\Projects\eclipse\.metadata\.plugins\org.eclipse.ajdt.core\TS.generated.lst] #Files=79</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java</file></fixedFiles></bug><bug commit="c760895" fixdate="1132300000" id="116626" opendate="1132130000" status="resolved fixed"><buginformation><summary>116626 Load-time weaving - exception from the weaver</summary><description>Hi again :-) I'm trying to use loadtime weaving and getting an exception. Please look at the testcase: Java code: ========== public class Test&lt;T&gt; { Set&lt;T&gt; intsSet; public Test() { this.intsSet = new HashSet&lt;T&gt;(); } public &lt;T&gt; T[] getObjs(T[] a) { return intsSet.toArray(a); } public static void main(String[] args) { System.out.println("AAA :-)"); new TTT().foo(); } } class TTT { public void foo() { Test&lt;Object&gt; mt = new Test&lt;Object&gt;(); Object[] arr = mt.getObjs(new Object[]{}); } } Aspect: ======= public privileged aspect TestAspect { pointcut TestToArray(Test mt) : target(mt) &amp;&amp; !within(TestAspect); Object[] around(Test mt, Object[] objs) : TestToArray(mt) &amp;&amp; args(objs) &amp;&amp; execution(Object[] com.mprv.secsph.Test.getObjs(Object[])) { objs = proceed(mt, objs); System.out.println("GO Aspects!"); return objs; } } aop.xml ======= &lt;aspectj&gt; &lt;aspects&gt; &lt;aspect name="com.mprv.secsph.TestAspect"/&gt; &lt;/aspects&gt; &lt;weaver options="-verbose -XlazyTjp -showWeaveInfo"&gt; &lt;include within="com.mprv.*"/&gt; &lt;/weaver&gt; &lt;/aspectj&gt; Program output: ============== AAA :-) info weaving 'com/mprv/secsph/TestAspect' java.lang.NullPointerException at org.aspectj.weaver.tools.WeavingAdaptor$WeavingClassFileProvider.getBytes (WeavingAdaptor.java:390) at org.aspectj.weaver.tools.WeavingAdaptor.getAtAspectJAspectBytes (WeavingAdaptor.java:259) at org.aspectj.weaver.tools.WeavingAdaptor.weaveClass (WeavingAdaptor.java:181) at org.aspectj.weaver.loadtime.Aj.preProcess(Aj.java:66) at org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter.transform (ClassPreProcessorAgentAdapter.java:52) at sun.instrument.TransformerManager.transform (TransformerManager.java:122) at sun.instrument.InstrumentationImpl.transform (InstrumentationImpl.java:155) at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:620) at java.security.SecureClassLoader.defineClass (SecureClassLoader.java:124) at java.net.URLClassLoader.defineClass(URLClassLoader.java:260) at java.net.URLClassLoader.access$100(URLClassLoader.java:56) at java.net.URLClassLoader$1.run(URLClassLoader.java:195) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:188) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:268) at java.lang.ClassLoader.loadClass(ClassLoader.java:251) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:319) at com.mprv.secsph.Test.getObjs(Test.java:1) at com.mprv.secsph.TTT.foo(Test.java:34) at com.mprv.secsph.Test.main(Test.java:27) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke (NativeMethodAccessorImpl.java:39) at sun.reflect.DelegatingMethodAccessorImpl.invoke (DelegatingMethodAccessorImpl.java:25) at java.lang.reflect.Method.invoke(Method.java:585) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:86) GO Aspects! ==== This exception doesn't happen all the time ... but if you will try a few times, you will probably get it. May you can understand what is the problem event without running the test case. Anyway, I took a look at your code, and have a guess (but it's only the guess) - My aspect is in the application classpath. Actually it's in the same package, so may be you are trying to weave the aspect with itself somehow ... Thanks! Misha.</description></buginformation><fixedFiles><file>tests/bugs150/pr116626/com/foo/bar/Test.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file></fixedFiles></bug><bug commit="62d16d5" fixdate="1130930000" id="113510" opendate="1130150000" status="resolved fixed"><buginformation><summary>113510 readAspect</summary><description>clearly define what the goal for readAspect is old byte per byte reading cause NPE in some test case current impl is hashcode for aspect name + classloader - ie unstable across startups.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file></fixedFiles></bug><bug commit="70888dd" fixdate="1130150000" id="113511" opendate="1130150000" status="resolved fixed"><buginformation><summary>113511 LTW enhancements</summary><description>Alex, here is the basic patch that is working well before you leave for the weekend ;-) I'll let Matthew post it officially to bugzilla since it was his idea. The earlier return from !enabled is a small addition I made that seems to help further. It would be great to have this in HEAD so I can report performance numbers based on it in part 2 of my article on developerworks ;-) Hope you are enjoying your new addition! Thanks! Index: ClassLoaderWeavingAdaptor.java =================================================================== RCS file: /home/technology/org.aspectj/modules/loadtime/src/org/aspectj/weaver/loadtim e/ClassLoaderWeavingAdaptor.java,v retrieving revision 1.18 diff -u -r1.18 ClassLoaderWeavingAdaptor.java --- ClassLoaderWeavingAdaptor.java 19 Oct 2005 13:11:36 -0000 1.18 +++ ClassLoaderWeavingAdaptor.java 21 Oct 2005 16:04:41 -0000 @@ -107,8 +107,13 @@ // register the definitions registerDefinitions(weaver, loader); + if (!enabled) { + return; + } messageHandler = bcelWorld.getMessageHandler(); + bcelWorld.setResolutionLoader((ClassLoader)null);//loader.getParent()); + // after adding aspects weaver.prepareForWeave(); } @@ -148,7 +153,11 @@ definitions.add(DocumentParser.parse(xml)); } } - + if (definitions.isEmpty()) { + enabled = false; + return; + } + // still go thru if definitions is empty since we will configure // the default message handler in there registerOptions(weaver, loader, definitions);</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/Aj.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file></fixedFiles></bug><bug commit="332a5df" fixdate="1129350000" id="107299" opendate="1124340000" status="resolved fixed"><buginformation><summary>107299 -aspectpath -inpath arguments fail without drive letter</summary><description>ajc doesn't recognize Windows absolute file paths that don't start with a drive letter, e.g., run: ajc -inpath \test.jar [error] build config error: bad inpath component: \test.jar but ajc -inpath c:\test.jar works ajc -aspectpath \test.jar Test.aj [error] build config error: bad aspectpath: \test.jar ajc -aspectpath c:\test.jar Test.aj (works)</description></buginformation><fixedFiles><file>util/src/org/aspectj/util/ConfigParser.java</file></fixedFiles></bug><bug commit="04e8dca" fixdate="1129200000" id="112243" opendate="1129060000" status="resolved fixed"><buginformation><summary>112243 Compiler Core Dump with Apparent Fix</summary><description /></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWorld.java</file></fixedFiles></bug><bug commit="81a0790" fixdate="1128010000" id="108118" opendate="1125070000" status="resolved fixed"><buginformation><summary>108118 Complete implementation of @SuppressAjWarnings</summary><description>ensure that @SuppressAJWarnings are indeed suppressed during pointcut operations. This requires wrapping major pointcut operations with calls to Lint from the associated advice.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file><file>weaver/src/org/aspectj/weaver/bcel/Utility.java</file></fixedFiles></bug><bug commit="85a4b0a" fixdate="1127940000" id="101047" opendate="1119360000" status="resolved fixed"><buginformation><summary>101047 Weaver produces wrong local variable table bytecode</summary><description>AspectJ version: DEVELOPMENT (also observed in 1.2.1) When weaving with a before or after advice, the generated local variable table will, on branch instructions, offset the "length" field of a local variable wrongly by one instruction. Also, the weaver will mix up local variables with the same name, thus violating the java VM specification: // Test.aj aspect Test { before() : ( execution(* Foo.foo(..) ) ) { System.out.println("before"); } // Foo.java public class Foo { private String myString = "A String"; public static void main(String[] args) { new Foo().foo(); } private void foo() { String myLocal = myString; if (myLocal.endsWith("X")) { String local1 = "local1"; System.out.println(local1); } else if (myLocal.endsWith("Y")) { String local2 = "local2"; System.out.println(local2); } else { String local1 = "local3"; System.out.println(local1); } } } --- We compilw with ajc -sourceroots . and dumps Foo with javap: javap -c -l -s -private Foo .... .... private void foo(); Signature: ()V Code: 0: invokestatic #65; //Method Test.aspectOf:()LTest; 3: invokevirtual #68; //Method Test.ajc$before$Test$1$f0485e90:()V 6: aload_0 7: getfield #15; //Field myString:Ljava/lang/String; 10: astore_1 11: aload_1 12: ldc #30; //String X 14: invokevirtual #36; //Method java/lang/String.endsWith: (Ljava/lang/String;)Z 17: ifeq 33 20: ldc #38; //String local1 22: astore_2 23: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 26: aload_2 27: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 30: goto 65 33: aload_1 34: ldc #52; //String Y 36: invokevirtual #36; //Method java/lang/String.endsWith: (Ljava/lang/String;)Z 39: ifeq 55 42: ldc #54; //String local2 44: astore_2 45: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 48: aload_2 49: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 52: goto 65 55: ldc #56; //String local3 57: astore_2 58: getstatic #44; //Field java/lang/System.out:Ljava/io/PrintStream; 61: aload_2 62: invokevirtual #50; //Method java/io/PrintStream.println: (Ljava/lang/String;)V 65: return LineNumberTable: line 7: 6 line 8: 11 line 9: 20 line 10: 23 line 11: 33 line 12: 42 line 13: 45 line 15: 55 line 16: 58 line 18: 65 LocalVariableTable: Start Length Slot Name Signature 6 60 0 this LFoo; 11 55 1 myLocal Ljava/lang/String; 45 12 2 local2 Ljava/lang/String; 23 43 2 local1 Ljava/lang/String; We see that the two occurences of the "local1" variable erroneously have been combined into one entry, starting at byte 23 and ending at byte 66. This is obviously wrong, since "local1" has no value in the "local2" block. Secondly, the "local2" variable end is wrongly offset by one instruction offset.</description></buginformation><fixedFiles><file>bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java</file></fixedFiles></bug><bug commit="03b20bc" fixdate="1127490000" id="109173" opendate="1126280000" status="resolved fixed"><buginformation><summary>109173 Weaving Adaptor enhancements for performance, configuration and diagnosis</summary><description>Here are some suggested enhancements as a result of exhaustive testing in the Eclipse/OSGi environment. 1. If no aspects are declared for a particular class loader, either because there are no visible aop.xml files or they contain no aspect definitions, then we should short-circuit the implementation of weaveClass() so that byte-code is not unnecessarily passed to the weaver. This is especially important under OSGi where there may be hundreds of class bundles, each with their own class loader only some of which are being woven. We can use the existing enabled flag. 2. As previously discussed on aspectj-dev the META-INF directory is considered private in OSGi and is therefore an inappropriate location for aop.xml files declaring shared aspects. I therefore propose a System property to set the a resource names for finding aop.xml files which would default to META-INF/aop.xml e.g. -Dorg.aspectj.weaver.loadtime.configuration=META- INF/aop.xml;org/aspectj/aop.xml. 3. We should not be catching Throwable in Aj. Instead we should catch known exceptions e.g. BCException and issue messages while letting other runtime exceptions pass back to the class loader. A user provided IMessageHandler implementation can decide under what circumstances to abort. Alternatively if Aj is considered to be a safe interface for weaving agents e.g. JVMTI then the dump logic it contains should be moved to the WeavingAdaptor so that it can be used directly from a class loader.</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/Aj.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java</file><file>loadtime/src/org/aspectj/weaver/loadtime/IWeavingContext.java</file></fixedFiles></bug><bug commit="c6bc7a2" fixdate="1125600000" id="102459" opendate="1120210000" status="resolved fixed"><buginformation><summary>102459 provide more detail in -showWeaveInfo messages</summary><description>When advice is executed, the object you have to work with is the joinpoint. This can then be queried to get various information out of it. It would be nice, if as part of the weaving you could get hold of the same information. This is particularly useful in the case of writing a coverage tool. In order to measure where you've been, you have to know all the places you could possibly go. The introduction of the -showWeaveInfo option means that we can record these places, however, this would be greatly enhanced by providing similar information as to that which is collected as the program is running. The information which would be good is the same as that obtained from JoinPoint.StaticPart.getSignature().toLongString().</description></buginformation><fixedFiles><file>bridge/src/org/aspectj/bridge/WeaveMessage.java</file><file>tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file></fixedFiles></bug><bug commit="7d5002a" fixdate="1118910000" id="100227" opendate="1118850000" status="resolved fixed"><buginformation><summary>100227 [generics][itds] inner class with generic enclosing class</summary><description>ajc crashes with a NullPointerException when an intertype declaration tries to modify an inner class, if the enclosing (outer) class is generic: class Outer { class Inner {} } class Generic_Outer&lt;T&gt; { class Inner {} } aspect Injector { int Outer.outer; // works int Outer.Inner.inner; // works int Generic_Outer.outer; // works int Generic_Outer.Inner.inner; // crashes } /home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:202) at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.build(InterTypeFieldDeclaration.java:173) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.buildInterTypeAndPerClause(AspectDeclaration.java:1020) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.buildInterTypeAndPerClause(AjLookupEnvironment.java:306) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment.completeTypeBindings(AjLookupEnvironment.java:122) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java:302) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:316) ...</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/TypeX.java</file></fixedFiles></bug><bug commit="588023e" fixdate="1118760000" id="99168" opendate="1118330000" status="resolved fixed"><buginformation><summary>99168 [generics][itds] ITD on generic inner class crashes ajc</summary><description>inter-type declaration on a generic inner class crashes the compiler: class Outer { class Inner {} class Generic_Inner&lt;T&gt; {} } class Generic_Outer&lt;T&gt; { } aspect Injector { int Outer.outer; // works int Outer.Inner.inner; // works int Generic_Outer.outer; // works int Outer.Generic_Inner.inner; // crashes } /home/user/sgelin3/dev/java/ajc/new_bug/Bug.java [error] Internal compiler error java.lang.RuntimeException: can't handle: class Generic_Inner#RAW extends NULL TYPENULL SUPERINTERFACES enclosing type : OuterNULL FIELDSNULL METHODS at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.makeSourceTypeBinding(InterTypeScope.java:35) at org.aspectj.ajdt.internal.compiler.lookup.InterTypeScope.&lt;init&gt;(InterTypeScope.java:28) at org.aspectj.ajdt.internal.compiler.ast.InterTypeDeclaration.resolve(InterTypeDeclaration.java:101) at org.aspectj.ajdt.internal.compiler.ast.InterTypeFieldDeclaration.resolve(InterTypeFieldDeclaration.java:141) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1076) at org.aspectj.ajdt.internal.compiler.ast.AspectDeclaration.resolve(AspectDeclaration.java:110) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.resolve(TypeDeclaration.java:1125) ...</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java</file></fixedFiles></bug><bug commit="a675b65" fixdate="1117640000" id="81846" opendate="1103800000" status="resolved fixed"><buginformation><summary>81846 EclipseAdapterUtils.java:83</summary><description>java.lang.ArrayIndexOutOfBoundsException: 3 Unfortunately I can't provide much more information, please see the attached compiler dump.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java</file></fixedFiles></bug><bug commit="f14646f" fixdate="1117450000" id="96371" opendate="1116880000" status="resolved fixed"><buginformation><summary>96371 Patch to support loading aop.xml properly</summary><description>AspectJ 5 load-time weaving in CVS HEAD isn't loading aop.xml files properly from a jar file without specifying the global -D flag. The following patch fixes the problem for me so I can load aop.xml files from jars on the classpath without a global flag: ClassLoaderWeavingAdaptor.java:109: - Enumeration xmls = loader.getResources("/META-INF/aop.xml"); + Enumeration xmls = loader.getResources("META-INF/aop.xml"); I.e., getResources doesn't work with a leading separator, at least not on the Sun VM or JRockIt on Windows. Writing a unit test for this would require significant changes to the loadtime module, so I wrote a standalone test of the API: public class TestApi extends TestCase { public void testLoadResource() throws Exception { URL urlList[] = { new URL ("file:testsrc/org/aspectj/weaver/loadtime/test/sample.jar") }; ClassLoader loader = new URLClassLoader(urlList); Enumeration xmls = loader.getResources("META-INF/aop.xml"); //this version fails: //Enumeration xmls = loader.getResources("/META-INF/aop.xml"); assertTrue(xmls.hasMoreElements()); } }</description></buginformation><fixedFiles><file>loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java</file><file>loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java</file><file>tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java</file></fixedFiles></bug><bug commit="df7fff4" fixdate="1113500000" id="82171" opendate="1104870000" status="resolved fixed"><buginformation><summary>82171 enable ASM interoperability with JavaCore via uniform element handles</summary><description /></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/AsmManager.java</file><file>asm/src/org/aspectj/asm/IElementHandleProvider.java</file><file>asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java</file><file>asm/src/org/aspectj/asm/internal/FullPathHandleProvider.java</file><file>asm/src/org/aspectj/asm/internal/ProgramElement.java</file><file>docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file><file>weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java</file><file>weaver/src/org/aspectj/weaver/ShadowMunger.java</file></fixedFiles></bug><bug commit="b0f270e" fixdate="1111590000" id="76055" opendate="1097570000" status="resolved fixed"><buginformation><summary>76055 Some Pointcut PatternNodes are missing getters to traverse syntax tree</summary><description>In order to find out which other pointcuts are referenced by a pointcut definition i need to access the private members of the CflowPointcut, IfPointcut and NotPointcut PatternNodes found in the weaver module. Unlike the OrPointcut and AndPointcut classes, they are missing the appropriate getter methods.</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file></fixedFiles></bug><bug commit="b5f4d09" fixdate="1111500000" id="88652" opendate="1111420000" status="resolved fixed"><buginformation><summary>88652 an array type as the last parameter in a signature does not match on the varargs declared method</summary><description>I get this warning in my code, though I actually do not specify an array type. The signature I want to match is the following constructor signature: public Touple(Object formulaHandle, Object... propositions) {...} Touple implements IRelation The pointcut I use is the following: pointcut p(): call(Touple.new(..)); This should actually match the signature, shouldn't it? AspectJ however complains with this warning: an array type as the last parameter in a signature does not match on the varargs declared method: void ltlrv.Touple.&lt;init&gt;(java.lang.Object, java.lang.Object[]) [Xlint:cantMatchArrayTypeOnVarargs] Also, even if I *had* stated an array type, it should match even then IMHO, since arrays and varargs are actually the same in the Java implementation.</description></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file></fixedFiles></bug><bug commit="85aa152" fixdate="1110460000" id="87376" opendate="1110290000" status="resolved fixed"><buginformation><summary>87376 NPE when unresolved type of a bound var in a pointcut expression (EclipseFactory.java:224)</summary><description>see attached mini-project to reproduce</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file><file>tests/bugs150/pr87376/I.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file></fixedFiles></bug><bug commit="f90186c" fixdate="1110380000" id="86789" opendate="1109540000" status="resolved fixed"><buginformation><summary>86789 annotations and "circularity in declare precedence"</summary><description /></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file></fixedFiles></bug><bug commit="5765d53" fixdate="1106850000" id="83565" opendate="1106600000" status="resolved fixed"><buginformation><summary>83565 BCException "bad type name" thrown when compiling</summary><description>I just downloaded AJDT version 1.2.0.20050124144759 and I am running Eclipse 3.1M4. I tried to use aspectJ on an existing Java 5 project. There are no aspects in it yet, just straight Java 5. The project runs just fine as a standard Java project. When add the AspectJ nature and I try to compile the project, no class files are generated and I get this error generated on a type that is parameterized: Internal compiler error org.aspectj.weaver.BCException: Bad type name: at org.aspectj.weaver.TypeX.nameToSignature(TypeX.java:634) at org.aspectj.weaver.TypeX.forName(TypeX.java:87) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBinding(EclipseFactory.java:155) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.fromBindings(EclipseFactory.java:163) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:229) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.makeResolvedMember(EclipseFactory.java:224) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.visit(AsmHierarchyBuilder.java:675) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration.traverse(ConstructorDeclaration.java:447) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse(TypeDeclaration.java:1133) at org.aspectj.org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse(CompilationUnitDeclaration.java:314) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.internalBuild(AsmHierarchyBuilder.java:171) at org.aspectj.ajdt.internal.core.builder.AsmHierarchyBuilder.buildStructureForCompilationUnit(AsmHierarchyBuilder.java:111) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit(EclipseFactory.java:354) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterProcessing(AjCompilerAdapter.java:138) at org.aspectj.org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:373) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:682) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:168) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:102) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:122) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run(AspectJBuildManager.java:165) The source code of the file that generates this error is: package mj.compiler.ast; import java.util.Vector; import mj.compiler.Driver; import mj.compiler.Visitor; public class Sequence&lt;T extends AST&gt; extends AST { private Vector&lt;T&gt; elements = new Vector&lt;T&gt;(); public Sequence() { super(0, 0); } public Sequence(T element) { super(element); elements.add(element); } public int length() { return elements.size(); } public T elementAt(int i) { return elements.elementAt(i); } public Sequence add(T element) { elements.add(element); return this; } public Sequence add(int pos, T element) { elements.add(pos, element); return this; } public Sequence addAll(Sequence&lt;T&gt; others) { if( others == null ) return this; elements.addAll(others.elements); return this; } public void visitChildren(Visitor v) { for( AST element : elements ) { element.visit(v); } } public void replaceChild(AST old, AST gnu) { T NEW = (T)gnu; for(int i = 0; i &lt; elements.size(); i++ ) { if( elements.get(i) == old ) { elements.set(i, NEW); return; } } throw new Driver.CompileError("Can't find child in replaceChild."); } /*** START GENERATED VISITOR PROTOCOL ***///TODO public void visit(mj.compiler.Visitor v) { v.visitSequence(this); } /*** END GENERATED VISITOR PROTOCOL ***/ } Hope this helps something. ps- I am able to create and run a very simple AspectJ project with an aspect, advice, and some Java 5 syntax.</description></buginformation><fixedFiles><file>ajde/testdata/bug-83565/Bug.java</file><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/GenericsTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file></fixedFiles></bug><bug commit="1b01255" fixdate="1106680000" id="83563" opendate="1106600000" status="resolved fixed"><buginformation><summary>83563 pertypewithin() handing of inner classes</summary><description /></buginformation><fixedFiles><file>tests/bugs150/PR83563_1.java</file><file>tests/bugs150/PR83563_2.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java</file><file>weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java</file></fixedFiles></bug><bug commit="5d281fd" fixdate="1106230000" id="83303" opendate="1106230000" status="resolved fixed"><buginformation><summary>83303 complier error when mixing inheritance, overriding and polymorphism</summary><description>Given this scenario: - class A define method m1 (with proteceted visibility) - class B extends class A and implements interface I and override method m1 (but with public visibility) - interface I define method m1 (with public visibility) The code is correct and compile using java 1.4 Let's modify the scenario: move the method B.m1 into a method introduction on aspect C, such that - class B extends class A - apsect C intosuces method m1 into B (with public visibility) and makes B implemts I (declare parents) - A and I as before The compiler reports this error: B.java:1 [error] The inherited method A.m1() cannot hide the public abstract method in I class B extends A {</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java</file><file>tests/bugs150/PR83303.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java</file></fixedFiles></bug><bug commit="f70b383" fixdate="1105590000" id="82218" opendate="1104920000" status="resolved fixed"><buginformation><summary>82218 fails to doc spacewar using AJDT 1.2.0M2</summary><description>Using AJDT 1.2.0M2 {with Java 5 JRE on XP SP2}, install Spacewar example and generate to Spacewar/docs. Result: output has no cross-references (and displays special AJDT tags), and stderr lists this exception: java.lang.StringIndexOutOfBoundsException: String index out of range: -1 at java.lang.AbstractStringBuilder.insert(AbstractStringBuilder.java:980) at java.lang.StringBuffer.insert(StringBuffer.java:447) at org.aspectj.tools.ajdoc.HtmlDecorator.insertDeclarationsDetails(HtmlDecorator.java:350) at org.aspectj.tools.ajdoc.HtmlDecorator.addAspectDocumentation(HtmlDecorator.java:234) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFile(HtmlDecorator.java:188) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecl(HtmlDecorator.java:116) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromDecls(HtmlDecorator.java:54) at org.aspectj.tools.ajdoc.HtmlDecorator.decorateHTMLFromInputFiles(HtmlDecorator.java:43) at org.aspectj.tools.ajdoc.Main.main(Main.java:210)</description></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java</file><file>ajdoc/src/org/aspectj/tools/ajdoc/Util.java</file><file>ajdoc/testdata/coverage/foo/ModelCoverage.java</file><file>ajdoc/testdata/coverage/foo/NoMembers.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/JDKVersionTest.java</file></fixedFiles></bug><bug commit="797b6a6" fixdate="1105110000" id="82134" opendate="1104850000" status="resolved fixed"><buginformation><summary>82134 AspectJ 5 M2 should implement backwards compatibility for binary aspect form</summary><description /></buginformation><fixedFiles><file>tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java</file><file>tests/src/org/aspectj/systemtest/ajc150/MigrationTests.java</file><file>weaver/src/org/aspectj/weaver/AdviceKind.java</file><file>weaver/src/org/aspectj/weaver/AjAttribute.java</file><file>weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java</file><file>weaver/src/org/aspectj/weaver/VersionedDataInputStream.java</file><file>weaver/src/org/aspectj/weaver/WeaverStateInfo.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelField.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelMethod.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file><file>weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/AndPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java</file><file>weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/Declare.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareParents.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/NamePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/NotPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/OrPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerCflow.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerClause.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerObject.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerSingleton.java</file><file>weaver/src/org/aspectj/weaver/patterns/Pointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePatternList.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java</file><file>weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java</file></fixedFiles></bug><bug commit="8a8930f" fixdate="1104940000" id="81863" opendate="1103820000" status="resolved fixed"><buginformation><summary>81863 Annotation matching using within() PCD doesn't appear to be working.</summary><description /></buginformation><fixedFiles><file>tests/java5/annotations/within/PlainWithin.java</file><file>tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java</file><file>tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java</file><file>weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java</file></fixedFiles></bug><bug commit="9897659" fixdate="1104840000" id="82062" opendate="1104610000" status="resolved fixed"><buginformation><summary>82062 WeaveMessage should provide more information</summary><description>It would be wonderful if the WeaveMessage object would provide two additional things: - the affected class name - the aspect name I could use this to determine which aspect is woven into which class during load-time weaving (need this for dependency management).</description></buginformation><fixedFiles><file>bridge/src/org/aspectj/bridge/WeaveMessage.java</file><file>weaver/src/org/aspectj/weaver/Advice.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWorld.java</file></fixedFiles></bug><bug commit="427c0d3" fixdate="1103550000" id="80916" opendate="1103020000" status="resolved fixed"><buginformation><summary>80916 In some cases the structure model doesn't contain the "matches declare" relationship</summary><description>With a project containing one class and one aspect: public class HelloClass { public static void main(String[] args) { new HelloClass().sayHello(); } public void sayHello() { System.out.println("Hello"); } } public aspect A1 { pointcut test() : get(* System.out); declare warning : test() &amp;&amp; !within(A1) : "test warning"; pointcut anotherTest() : execution(void HelloClass.sayHello(..)); after() returning : anotherTest() { System.out.println("returning...."); } } The following is returned from the structure model: asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: uses pointcut, target: A1.anotherTest() asmRelMap entry: A1.afterReturning(): anotherTest.., relationship: advises, target: HelloClass.sayHello() asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.anotherTest(), relationship: pointcut used by, target: A1.afterReturning(): anotherTest.. asmRelMap entry: A1.declare warning: "test warning", relationship: matched by, target: HelloClass.sayHello() In other words, the model is saying that there are two entries the same: asmRelMap entry: HelloClass.sayHello(), relationship: advised by, target: A1.afterReturning(): anotherTest.. whereas one of these should be the "matches declare" relationship relating to the declare warning. Changing the aspect to be: public aspect A1 { pointcut test() : get(* System.out); declare warning : test() &amp;&amp; !within(A1) : "test warning"; pointcut anotherTest() : execution(void HelloClass.sayHello(..)); after() returning : anotherTest() { System.out.println("returning...."); } after() returning : test() { System.out.println("returning again!"); } } means that the IRelationshipMap does now contain the "matches declare" relationship. This is all with AspectJ 5 M1.</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java</file></fixedFiles></bug><bug commit="9052d5d" fixdate="1102330000" id="80249" opendate="1102330000" status="resolved fixed"><buginformation><summary>80249 Order of types passed to compiler determines weaving behavior</summary><description>Currently, the order in which you specify types when passing them to the compiler can affect how they are woven: For example, if we have class A and class B extends A - Also, an aspect that 'declare parents: A+ implements Serializable' then depending on whether we see A first, we may or may not make B serializable. The fix is that when we weave a type, we first weave its supertype then its superinterfaces (if they were also passed to the compiler). The problematic construct is declare parents - so we only process the types in a special order if there are declare parents around. Also, because we can't currently do decp when binary weaving, the order processing logic is only being put into the source weaving pipeline.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file><file>tests/decp/A.java</file><file>tests/decp/AspectX.java</file><file>tests/decp/B.java</file><file>tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java</file></fixedFiles></bug><bug commit="edd6539" fixdate="1099650000" id="77163" opendate="1098920000" status="resolved fixed"><buginformation><summary>77163 Load time weaver default verbose setting</summary><description>The default setting for the load time weaver is (as of 1.2.1rc1) to produce weaving messages rather than ignore them. I think the default should be changed to ignore them. Also, I cannot override the default setting with -Daj.weaver.versose="False". This is the implied syntax from docs/examples/build.xml. If this has changed then build.xml should be updated. Otherwise, the weaver should be fixed to use it!</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file><file>weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java</file></fixedFiles></bug><bug commit="aab9c2c" fixdate="1099580000" id="77799" opendate="1099550000" status="resolved fixed"><buginformation><summary>77799 NullPointerException in StructureSearchManager</summary><description>Calling Ajde.getDefault().getStructureSearchManager().findMatches(...) for an AspectJ project that has not been built results in a NullPointerException in StructureSearchManager.findMatchesHelper(...) (line 58) Simple patch is attached.</description></buginformation><fixedFiles><file>ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java</file></fixedFiles></bug><bug commit="6aa7516" fixdate="1098440000" id="76798" opendate="1098440000" status="resolved fixed"><buginformation><summary>76798 Add versions to woven class files - enabling better backwards compatibility.</summary><description>We don't currently include a version in the class files that come out of the weaver. This can cause problems. For example, if we add a new attribute to a class file in a future version of AspectJ, then that attribute will cause older versions of AspectJ to blow up if they encounter it. If we include a version in the class file we can rev the version number when we add attributes (or change the class file form in another way), and by checking that version number in the weaver we can better determine whether we should fail if we encounter a new attribute (or other change), or if it is safe to continue processing. I will add a new WeaverVersion attribute that includes 2 shorts. Major and Minor. Encountering a major version in a class file that is greater than the version a particular weaver is designed to understand will cause compilation to fail. Encountering a minor version in a class file that is greater than the minor version a particular weaver is designed to understand will not cause compilation to fail - we will assume it is safe to continue.</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/AjAttribute.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelField.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelMethod.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file></fixedFiles></bug><bug commit="a303a09" fixdate="1098360000" id="74952" opendate="1096040000" status="resolved fixed"><buginformation><summary>74952 before,after !(cflow(within(Trace*))) prints nothing</summary><description>Reference: "cflow(within(C)) vs (within(C)||cflowbelow(within(C)) in aspectj-users mailing list. The aspect TraceClass below doesn't print any message when the pointcut is defined to "!cflow(within(Trace*))". The other defintion "!(within(Trace*) || cflowbelow(within(Trace*)))" works fine. Wes Isberg in his reply explained that cflow should never be used alone but he thought "there is a bug or two in here" class SomeClass { static public void main (String [] args) { } } // SomeClass aspect TraceClass { // members static private int level = 0; static private void offset() { int i; for (i = 0; i &lt; level; ++i) { System.out.print(" "); } } // offset pointcut pc() : !cflow(within(Trace*)) // !(within(Trace*) || cflowbelow(within(Trace*))) ; before () : pc() { offset(); System.out.println("-&gt; " + thisJoinPoint); ++level; } after () : pc() { --level; offset(); System.out.println("&lt;- " + thisJoinPoint); } } // TraceClass In order to try to figure out what is happening within TraceClass, I added a second aspect, TraceTrace, just to trace TraceClass. aspect TraceTrace { // members static private int level = 0; static private void offset() { int i; for (i = 0; i &lt; level; ++i) { System.out.print(" "); } } // offset pointcut pc() : within(TraceClass); before () : pc() { offset(); System.out.println("=&gt; " + thisJoinPoint); ++level; } after () : pc() { --level; offset(); System.out.println("&lt;= " + thisJoinPoint); } } // TraceTrace Here is what TraceTrace prints when TraceClass uses "!cflow(within(Trace*))" =&gt; staticinitialization(TraceClass.&lt;clinit&gt;) =&gt; set(int TraceClass.level) &lt;= set(int TraceClass.level) =&gt; preinitialization(TraceClass()) =&gt; initialization(TraceClass()) =&gt; execution(TraceClass()) &lt;= execution(TraceClass()) &lt;= initialization(TraceClass()) &lt;= staticinitialization(TraceClass.&lt;clinit&gt;) The after advice is not executed for preinitialization.</description></buginformation><fixedFiles><file>tests/bugs/WhatsGoingOn.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="6beb43f" fixdate="1098180000" id="76096" opendate="1097600000" status="resolved fixed"><buginformation><summary>76096 Anonymous classes unaware of introductions into abstract classes (error can't find type $Local$)</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java</file><file>tests/bugs/pr76096/ConcreteClassA.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="6e155a6" fixdate="1097740000" id="74238" opendate="1095590000" status="resolved fixed"><buginformation><summary>74238 Applet which uses cflow pointcut gets AccessControlException</summary><description>When I used cflow pointcut for my applet, I couldn't launch the Applet. java.lang.ExceptionInInitializerError at SandAspect.ajc$preClinit(SandAspect.aj) at SandAspect.&lt;clinit&gt;(SandAspect.aj) at SandApplet.init(SandApplet.java) at sun.applet.AppletPanel.run(AppletPanel.java:353) at java.lang.Thread.run(Thread.java:534) Caused by: java.security.AccessControlException: access denied (java.util.Proper tyPermission aspectj.runtime.cflowstack.usethreadlocal read) at java.security.AccessControlContext.checkPermission(AccessControlConte xt.java:269) at java.security.AccessController.checkPermission(AccessController.java: 401) at java.lang.SecurityManager.checkPermission(SecurityManager.java:524) at java.lang.SecurityManager.checkPropertyAccess(SecurityManager.java:12 76) at java.lang.System.getProperty(System.java:612) at org.aspectj.runtime.internal.CFlowStack.selectFactoryForVMVersion(CFl owStack.java:124) at org.aspectj.runtime.internal.CFlowStack.&lt;clinit&gt;(CFlowStack.java:59) ... 5 more It because CFlowStack uses System.getProperty method with no try..catch block. Applet doesn't have permission to read system property: "aspectj.runtime.cflowstack.usethreadlocal". workaround: modify CFlowStack.java(1.5) line 123,124 like this ----- private static String getSystemPropertyWithNoSecurityException( String aPropertyName, String aDefaultValue){ try{ return System.getProperty(aPropertyName, aDefaultValue); } catch(java.lang.SecurityException e){ return aDefaultValue; } } private static void selectFactoryForVMVersion() { String override = getSystemPropertyWithNoSecurityException( "aspectj.runtime.cflowstack.usethreadlocal" , "unspecified" ); ----- I think defining getSystemPropertyWithNoSecurityException(or more simple name :-)) method in some utility class and using it where you call System.getProperty are better way.</description></buginformation><fixedFiles><file>ajde/testdata/SecurityManagerTest/src/HelloWorld.java</file><file>runtime/src/org/aspectj/runtime/internal/CFlowCounter.java</file><file>runtime/src/org/aspectj/runtime/internal/CFlowStack.java</file></fixedFiles></bug><bug commit="eca1429" fixdate="1094650000" id="72157" opendate="1092830000" status="resolved fixed"><buginformation><summary>72157 declare soft can cause programs with invalid exception behaviour to be generated</summary><description>Compiling the program below results in the constructor for the class SCE2 throwing Exception, which it is not declared to throw either in the source code or in the generated bytecode. If the 'declare soft' statement is removed, then the super() call in the SCE2 constructor is correctly reported as throwing an undeclared exception; it seems that the 'declare soft' statement turns off the exception checking of the super() call despite there being no join point which covers this call that would actually soften the exception. I'm using 'DEVELOPMENT built on Monday Aug 16, 2004 at 13:50:47 GMT'. public class SuperConsExc { public SuperConsExc() throws Exception { throw new Exception(); } public static void main(String[] args) { new SCE2(); } } class SCE2 extends SuperConsExc { public SCE2() { super(); } } aspect SCEAspect { declare soft: Exception: within(SCE2); }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java</file><file>tests/bugs/ConvertToUnchecked.java</file><file>tests/bugs/PR72157.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="8e4d898" fixdate="1094640000" id="73433" opendate="1094640000" status="resolved fixed"><buginformation><summary>73433 AspectJ does not correctly support -cp</summary><description>Discovered by Andy Brodie. -cp is a shorthand for -classpath supported by the JDT compiler. AspectJ does not correctly support -cp option. Look at this example: C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -cp lib\aspectjrt.jar [error] can't find type org.aspectj.lang.JoinPoint 1 error C:\aspectj1.2&gt;ajc -inpath injar.jar -outjar outjar.jar -classpath lib\aspectjrt.jar This is due to the arg parser in AspectJ only recognizing -classpath. It doesn't fail when it encounters -cp, it just ignores it and passes it down to JDT for processing. The fix is to recognize -cp too.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file></fixedFiles></bug><bug commit="d1551bd" fixdate="1094480000" id="72671" opendate="1093520000" status="resolved fixed"><buginformation><summary>72671 Bootclasspath specification for compiling is not possible</summary><description>I have following bug running eclipse 3.0 and ajdt 1.1.12 I have following class: import java.io.FileNotFoundException; import java.io.FileOutputStream; import org.w3c.dom.DOMConfiguration; import org.w3c.dom.DOMError; import org.w3c.dom.DOMErrorHandler; import org.w3c.dom.Document; import org.w3c.dom.DocumentFragment; import org.w3c.dom.NodeList; import org.w3c.dom.ls.DOMImplementationLS; import org.w3c.dom.ls.LSInput; import org.w3c.dom.ls.LSOutput; import org.w3c.dom.ls.LSParser; import com.dcbank.common.DOMImplementationLSSingleton; public class DOMHelper { public static final String CLASS_ID = "%full_filespec: DOMHelper.java~1:java:1 %"; public static void save(Document document, String filename) throws ClassNotFoundException, InstantiationException, IllegalAccessException, FileNotFoundException { document.normalizeDocument(); } } which compiles very fine with JDK 1.4.2_02 on Windows XP, as soon as the dom2-xml-apis.jar and dom3-xercesImpl.jar are added at the beginning of the jre container, or are included in the jar-library list before the system jar. As soon as I convert this project to an AspectJ project, the code does not compile anymore. The aspectJ compiler does not find the normalizeDocument, which is included in the one of the two additional jars. method any more. kind regards Arno Schmidmeier</description></buginformation><fixedFiles><file>ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java</file></fixedFiles></bug><bug commit="27d204c" fixdate="1094220000" id="72528" opendate="1093370000" status="resolved fixed"><buginformation><summary>72528 around advice throws java.lang.VerifyError at runtime</summary><description>I have an aspect that captures around() a pcd and returns an Object[], though the actual methods being instrumented might return any valid POJO array, i understand that AspectJ will take care of casting at assignment. I expected the following code to work properly, but at runtime i get a java.lang.VerifyError as shown below: F:\wd\Hello&gt;ajbrowser HelloWorld.lst java.lang.VerifyError: (class: de/rohith/PrinterWorld, method: returnArrayWithCl oning signature: ()[Ljava/lang/Integer;) Incompatible argument to function at de.rohith.HelloWorld.main(HelloWorld.java:18) Exception in thread "main" I suspect the compiler fails to notice the return types of the methods being caught at compile time. I have tested this code with both ajbrowser as well as AJDT, both result in the same error output. -----------HelloWorldAspect.java--------------- package de.rohith; import java.lang.Object; public aspect HelloWorldAspect { private int callDepth = -1; public HelloWorldAspect() { } pointcut hello(): !within(HelloWorldAspect); pointcut method(): execution(public (*[]) de..*(..)); pointcut cloning(): call(* java.lang.Object.clone()); declare warning: method() &amp;&amp; hello(): "*[] returning method called" ; Object[] around(): cflow(method()) &amp;&amp; cloning() &amp;&amp; hello() { print("", thisEnclosingJoinPointStaticPart); Object[] ret = proceed(); return (Object[])ret.clone(); } private void print(String prefix, Object message) { for (int i = 0, spaces = callDepth * 2; i &lt; spaces; i++) { System.out.print(" "); } System.out.println(prefix + message); } } -----------PrinterWorld.java------------ package de.rohith; public class PrinterWorld { private Integer[] intArray = new Integer[2]; public PrinterWorld() { } public void print() { System.out.println("Hello World!"); } public Integer returnInt() { return new Integer(3); } public Integer[] returnArrayWithCloning() { for (int i = 0; i &lt; intArray.length; i++) { intArray[i] = new Integer(i++); } return (Integer[])intArray.clone(); } public Integer[] returnArrayWithoutCloning() { return intArray; } } -----------HelloWorld.java------------ package de.rohith; public class HelloWorld { public static void main(String[] args) { PrinterWorld p = new PrinterWorld(); p.print(); Integer i = p.returnInt(); Integer[] intArray = p.returnArrayWithCloning(); Integer[] array2 = p.returnArrayWithoutCloning(); } }</description></buginformation><fixedFiles><file>tests/bugs/ArrayCloning.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="4921f0c" fixdate="1094050000" id="46298" opendate="1068230000" status="resolved fixed"><buginformation><summary>46298 Aspectj generate code does not de-compile cleanly.</summary><description /></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="438e61c" fixdate="1094030000" id="49743" opendate="1073600000" status="resolved fixed"><buginformation><summary>49743 performance improvements for runtime library</summary><description>I am heavily using the runtime signature information from thisJoinPoint.getSignature() and the toString() method of it. This causes heavy String operations each time the toString method is called. Would it be possible to cache the resulting string for example in MethodSignatureImpl and similar classes for other signatures?</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/Factory.java</file><file>runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java</file><file>runtime/src/org/aspectj/runtime/reflect/StringMaker.java</file><file>runtime/testsrc/RuntimeModuleTests.java</file><file>runtime/testsrc/org/aspectj/runtime/reflect/RuntimePerformanceTest.java</file><file>runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java</file></fixedFiles></bug><bug commit="5e08765" fixdate="1093610000" id="72699" opendate="1093540000" status="resolved fixed"><buginformation><summary>72699 Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class</summary><description>When attempting to compile the following aspect the resulting error message should say something like "The abstract method pointcut tracingScope in type Tracing can only be defined by an abstract aspect" public aspect Tracing { public abstract pointcut tracingScope(); }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java</file><file>tests/bugs/BogusMessage.java</file><file>tests/bugs/BogusMessage2.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="b5e6307" fixdate="1093600000" id="72150" opendate="1092810000" status="resolved fixed"><buginformation><summary>72150 AJC possible bug with static nested classes</summary><description /></buginformation><fixedFiles><file>tests/bugs/java5/arrayCloning/A.java</file><file>tests/bugs/java5/arrayCloning/C.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/TypeX.java</file></fixedFiles></bug><bug commit="82eae55" fixdate="1093380000" id="72531" opendate="1093370000" status="resolved fixed"><buginformation><summary>72531 declare warning warns at wrong points</summary><description /></buginformation><fixedFiles><file>tests/bugs/pr72531/de/rohith/HelloWorld.java</file><file>tests/bugs/pr72531/de/rohith/HelloWorldAspect.java</file><file>tests/bugs/pr72531/de/rohith/PrinterWorld.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file><file>weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java</file></fixedFiles></bug><bug commit="f503523" fixdate="1093270000" id="72154" opendate="1092820000" status="resolved fixed"><buginformation><summary>72154 Support for simple dump file</summary><description>When the compiler terminates abnormally (exception) or behaves unexpectedly (warning/error/abort) a simple dump of the compiler state should be produced to aid problem diagnosis. The content and conditions under which the dump is produced should be configurable by the user but the facility should be enabled by default for exceptions. Consequently its inclusion should have negligible impact on compiler performance and footprint. The file should be attached to bug reports to give a complete and objective description of the users environment and support problem resolution where a testcase cannot be provided. One approach is to write a uniquely name file (using date &amp; time) in the current directory e.g ajcore.20040818.105200.txt which should be human readable (it can be zipped if large) to allow the user to potentially diagnose their own problems or remove potentially sensitive data before submission. It should contain basic information such as AspectJ version, system properties and command line as well as failure information such as _full_ exception stack trace, compiler messages and internal compiler state.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java</file><file>org.aspectj.ajdt.core/testdata/DumpTestCase/src/HelloWorld.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CompilerDumpTestCase.java</file><file>weaver/src/org/aspectj/weaver/Dump.java</file><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/testsrc/org/aspectj/weaver/BcweaverTests.java</file><file>weaver/testsrc/org/aspectj/weaver/DumpTestCase.java</file></fixedFiles></bug><bug commit="5f80c8c" fixdate="1092960000" id="71811" opendate="1092250000" status="resolved fixed"><buginformation><summary>71811 AJDoc: should be able to set encoding like javadoc</summary><description>ajdoc doesn't support the -encoding -docencoding and -charset options of javadoc. Especially, it doesn't pass on the -encoding to ajc. If your project uses a source file encoding (e.g. UTF-8) differing form the platform standard, and some java identifiers use characters byond the standard ASCII range, you won't be able to use ajdoc at all.</description></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/Main.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file></fixedFiles></bug><bug commit="dbe1024" fixdate="1092930000" id="49657" opendate="1073510000" status="resolved fixed"><buginformation><summary>49657 Weaver results in rt error if affected base class not exposed</summary><description>I was weaving a 3rd party library and wrote an aspect that should affect both a base class and a derived class, but inadvertently wove only the derived class. This resulted in the following error. I would like the weaver to catch this kind of error at weave (link) time, rather than creating code that results in a rt error... I get this error in 1.1.1 final and in a fairly recent version from CVS HEAD: java.lang.AbstractMethodError at ajee.logging.LogManager.ajc$interMethodDispatch1 $ajee_logging_LogManager$ajee_logging_Loggable$getLogger(LogManager.java) at ajee.tracing.ExecutionTracer.ajc$before$ajee_tracing_ExecutionTracer$926 (ExecutionTracer.java:62) at library.Derived.&lt;init&gt;(Derived.java:46) This line is a call to super(); I've attached a small example that reproduces another error that I think is related: C:\devel\test\ctors\twoPass&gt;build C:\devel\test\ctors\twoPass&gt;call ajc -outjar fullBase.jar sample\Base.java sampl e\Derived.java Exception in thread "main" java.lang.ExceptionInInitializerError at sample.Derived.&lt;init&gt;(Derived.java:6) at sample.Derived.main(Derived.java:13) Caused by: org.aspectj.lang.NoAspectBoundException at sample.Trace.aspectOf(Trace.aj) at sample.Trace.&lt;init&gt;(Trace.aj:5) at sample.Trace.ajc$postClinit(Trace.aj) at sample.Trace.&lt;clinit&gt;(Trace.aj:5) ... 2 more</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Base.java</file><file>org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Derived.java</file><file>org.aspectj.ajdt.core/testdata/partialHierarchy/sample/Iface.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PartiallyExposedHierarchyTestCase.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/WeaverMessages.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="dfb15c1" fixdate="1092830000" id="71723" opendate="1092160000" status="resolved fixed"><buginformation><summary>71723 Inconsistency in scoping of protected members in ITDs</summary><description>When introducing new member functions to existing classes via inter-type declarations, the scoping rules that apply to the ITD bodies are the same as for the aspect - for example, private members of the target class cannot be accessed unless the aspect is privileged. Similarly, protected members of classes in different packages should not be visible in ITDs unless the aspect is privileged. This rule is only enforced for protected members declared in the target class - protected members that are inherited are visible from ITDs in aspects in different packages. The following is an example of this: ---------------------- package foo; public class Foo extends AncientFoo { protected int i() { return 42; } public static void main(String[] args) { new Foo().doStuff(); } public void doStuff() { } protected int ancientI() { return 42; } } class AncientFoo { protected int ancientI() { return -42; } protected int ancientJ() { return 0; } } ---------- package bar; import foo.Foo; aspect Bar { public void Foo.doing() { try { System.out.println(i()); // fails in ajc System.out.println(ancientI()); // fails in ajc System.out.println(ancientJ()); // succeeds System.out.println(clone()); // succeeds } catch(Throwable t) { } } before(Foo f) : call(* doStuff(..)) &amp;&amp; target(f) { f.doing(); } } ------------------- All four calls in Foo.doing() should fail, as they refer to protected members of foo.Foo from package bar. However, only the first 2 - the ones directly declared/overridden in foo.Foo - are detected as errors, and removing them makes the rest compile and execute. Best wishes, Pavel</description></buginformation><fixedFiles><file>tests/bugs/pr71723/foo/Foo.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="84e4e53" fixdate="1092750000" id="62642" opendate="1084890000" status="resolved fixed"><buginformation><summary>62642 proper handling of ExceptionInIntializer inside &lt;clinit&gt; in presence of after throwing advice</summary><description>When a &lt;clinit&gt; of a class contains after throwing advice that may catch ExceptionInInitializer errors due to an embedded advice aspectOf() that fails, the ExceptionInIntializer error does not get properly reported. For the example below: public class Main { static int x = 13; int y; public Main() { y= 14; } public static void main(String args[]) { Main m = new Main(); m.y = 3; System.out.println("hi"); } } aspect Aspect { before () : within(*) { System.out.println("BEFORE " + thisJoinPointStaticPart.getKind() + " at " + thisJoinPointStaticPart.getSourceLocation()); } after () : within(*) { System.out.println("AFTER " + thisJoinPointStaticPart.getKind() + " at " + thisJoinPointStaticPart.getSourceLocation()); } } .... when compiled with ajc, and then run, the following exception is given, Exception in thread "main" java.lang.NoClassDefFoundError at Main.&lt;clinit&gt;(Main.java:1) when really one wants the following: Exception in thread "main" java.lang.ExceptionInInitializerError at Main. ... Caused by: org.aspectj.lang.NoAspectBoundException: Aspect at Aspect.aspectOf .. ------------- Here is a fix ... I give the decompiled &lt;clinit&gt; for Main.java and indicate with comments, look for ***LJH ****, what can be woven to fix it. Basically, the catch block for after throwing, when in &lt;clinit&gt;, should first check if the caught exception if a ExceptionInInitializerError, and if so just throw it. ----------- static { org.aspectj.runtime.reflect.Factory r1; java.lang.Throwable r2, r31; int $i0; r1 = new Factory("Main.java", Class.forName("Main")); ajc$tjp_0 = r1.makeSJP("field-set", r1.makeFieldSig("8-x-Main-int-"), 2); ajc$tjp_1 = r1.makeSJP("staticinitialization", r1.makeInitializerSig("8--Main-"), 2); ajc$tjp_10 = r1.makeSJP("preinitialization", r1.makeConstructorSig("1--Main----"), 5); ajc$tjp_2 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 6); ajc$tjp_3 = r1.makeSJP("constructor-execution", r1.makeConstructorSig("1--Main----"), 6); ajc$tjp_4 = r1.makeSJP("constructor-call", r1.makeConstructorSig("1--Main----"), 10); ajc$tjp_5 = r1.makeSJP("field-set", r1.makeFieldSig("0-y-Main-int-"), 11); ajc$tjp_6 = r1.makeSJP("field-get", r1.makeFieldSig("19-out-java.lang.System-java.io.PrintStream-"), 12); ajc$tjp_7 = r1.makeSJP("method-call", r1.makeMethodSig("1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"), 12); ajc$tjp_8 = r1.makeSJP("method-execution", r1.makeMethodSig("9-main-Main-[Ljava.lang.String;:-args:--void-"), 10); ajc$tjp_9 = r1.makeSJP("initialization", r1.makeConstructorSig("1--Main----"), 6); try { Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_1); $i0 = 13; try { Aspect.aspectOf().ajc$before$Aspect$1$36f01b1c(ajc$tjp_0); x = $i0; } catch (Throwable $r30) { /*** LJH insert here *****/ if ($r30 instanceof ExceptionInIntializerError) //*** throw($r30); //*** /***********/ r31 = $r30; Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0); throw r31; } Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_0); } catch (Throwable $r36) { /*** LJH insert here *****/ if ($r36 instanceof ExceptionInIntializerError) //*** throw($r36); //*** /***********/ r2 = $r36; Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1); throw r2; } Aspect.aspectOf().ajc$after$Aspect$2$36f01b1c(ajc$tjp_1); }</description></buginformation><fixedFiles><file>tests/bugs/pr62642.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="a2469c7" fixdate="1092740000" id="70241" opendate="1089990000" status="resolved fixed"><buginformation><summary>70241 outline view shows anonymous inner classes in different way than jdt outline</summary><description>See screenshots.</description></buginformation><fixedFiles><file>ajde/testdata/extensions/InnerClasses.java</file><file>ajde/testsrc/org/aspectj/ajde/ExtensionTests.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java</file></fixedFiles></bug><bug commit="2dfc738" fixdate="1092410000" id="71878" opendate="1092330000" status="resolved fixed"><buginformation><summary>71878 Bad injar aspect name on Linux</summary><description>If you checkout the "JarUsingProject" project from "org.eclipse.ajdt.test/manual testing" in the AJDT 1.1.12 tree, and look at the advised-by entries in the outline view and the context menu of the gutter annotation, on Windows you get "injar aspect: AbstractAspect.aj", but on Linux you get "injar aspect: C:\eclipse30AJDTPluginTest\eclipse\workspace\JarGeneratingProject\src\p1\AbstractAspect.aj". The Windows-style path indicates the location of the original class files in the JAR file, which was clearly built on Windows.</description></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java</file></fixedFiles></bug><bug commit="d43a391" fixdate="1092230000" id="54421" opendate="1078990000" status="resolved fixed"><buginformation><summary>54421 Compile time declarations (warning and error) do not accept string concatenation (with +)</summary><description>The following code does not compile because the message uses string concatenation (the + operator). public class WarningSample { public void method() {} public void anotherMethod() { this.method(); } } aspect WarningAspect { pointcut illegalCall(): call(* WarningSample.method()) &amp;&amp; within(WarningSample); // the same thing happens with declare error declare warning: illegalCall() : "Hey, don't " + "do that, that is not nice. You should do something else"; }</description></buginformation><fixedFiles><file>tests/bugs/decwStrings.java</file><file>tests/bugs/decwStringsErroneous.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/patterns/PatternParser.java</file></fixedFiles></bug><bug commit="64183c3" fixdate="1092230000" id="68991" opendate="1088600000" status="resolved fixed"><buginformation><summary>68991 intertype initialisers should match field set pointcuts</summary><description>/* initialisers of intertype fields should match field set pointcuts. In the example below, the output should be set field set(int C.n) set field set(int C.m) get field get(int C.n) set field set(int C.n) but the first field set (of C.n) is not picked up. */ aspect Aspect { private int C.n = 13; before() : get(* C.*) { System.out.println("get field "+thisJoinPointStaticPart); } before() : set(* C.*) { System.out.println("set field "+thisJoinPointStaticPart); } public void C.foo() { n++; } } class C { int m = 20; } public class ITFieldsAdvice { public static void main(String[] args) { C c = new C(); c.foo(); } }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java</file><file>tests/bugs/PR68991/Oxford.java</file><file>tests/bugs/PR68991/Simple.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="b75cd93" fixdate="1092150000" id="65319" opendate="1086190000" status="resolved fixed"><buginformation><summary>65319 ajc crashes when compiling the following program (binding this() and target())</summary><description>class Test { public static void main(String args[]) { new Test().method(); } public void method() { new Test2().method2(); } } class Test2 { public void method2() {} } aspect Plain { before(Test x): call(void *.* (..)) &amp;&amp; (this(x) || target(x)) { } }</description></buginformation><fixedFiles><file>tests/bugs/oxford/PR65319.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file><file>weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExposedState.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java</file></fixedFiles></bug><bug commit="05dabd1" fixdate="1092140000" id="53981" opendate="1078630000" status="resolved fixed"><buginformation><summary>53981 proceed used as method name in around advice</summary><description>Using a method named proceed(..) in around advice confuses the compiler (in at least the 2-3 ways shown below). True of the current tree (untested in 1.1.1). Workaround for now is to rename the method. ---- first problem: NPE in compiler java.lang.NullPointerException at org.aspectj.ajdt.internal.compiler.ast.MakeDeclsPublicVisitor.endVisit(MakeDeclsPublicVisitor.java:44) public class Proceeding { public static void main(String[] args) { } static aspect A { interface IProceed { void proceed(Runnable next); } IProceed decorator; void around() : execution(void main(String[])) { decorator.proceed(new Runnable() { public void run() { proceed(); } }); } } } ---- second problem: incorrect error wrt number of arguments public class Proceeding { public static void main(String[] args) { } static aspect A { void around() : execution(void main(String[])) { Proceeding.proceed(null); // BUG: treated as proceed(Object); } } static void proceed(Object o) {} } ---- third hypothetical: we should document how ambiguity is resolved public class Proceeding { public static void main(String[] args) { } static aspect A { void around() : execution(void main(String[])) { proceed(); // special form or Proceeding.proceed()? } } void proceed() {} }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file></fixedFiles></bug><bug commit="44a92e1" fixdate="1092140000" id="59208" opendate="1082450000" status="resolved fixed"><buginformation><summary>59208 Weaver fails in BCEL for large classes</summary><description /></buginformation><fixedFiles><file>tests/bugs/pr59208/Foo.java</file><file>tests/bugs/pr59208/FooProducer.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/WeaverMessages.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java</file></fixedFiles></bug><bug commit="f6436e3" fixdate="1092060000" id="67592" opendate="1087460000" status="resolved fixed"><buginformation><summary>67592 value in the args[] array of thisjoinpoint can be changed by one advice decl and updated values seen in another advice decl</summary><description>In ajc a use of thisJoinPoint corresponds to an object of type JoinPoint, where a JoinPoint object has four components, which can be retrieved using accessor methods. this getThis() target getTarget() args getArgs() staticJoinPoint getStaticPart() In the case of args, the object returned is an Object array. This means that an advice decl can overwrite the args, and then another advice which shares the same JoinPoint will see the changed args. Here is a small example. In this aspect the before advice changes arg[0] to always be "Laurie" and then the after advice will always say that "Laurie won a million pounds". Is this the behaviour that is intended? I would have thought that the interface to args[] should be such that the values can only be read. Otherwise very strange interactions between advice decls could occur. --------------------------------------------------------------------- public class Main { public static Main v = new Main(); void lottery ( String arg ) { System.out.println("The arg in lottery is " + arg); } public static void main (String args[]) { v.lottery("Oege"); v.lottery("Ganesh"); } } --------------------------------------------------------------------- public aspect Aspect { // This pair of advice decls demonstrates that an advice can change to // the args of a join point. before () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect) { System.out.println("BEFORE " + thisJoinPoint + " at " + thisJoinPointStaticPart.getSourceLocation()); Object args[] = thisJoinPoint.getArgs(); System.out.println("arg[0] is " + args[0]); args[0] = "Laurie"; System.out.println("... now it is " + thisJoinPoint.getArgs()[0]); } after () : call(* lottery(java.lang.String)) &amp;&amp; !within(Aspect) { System.out.println("AFTER " + thisJoinPoint + " at " + thisJoinPointStaticPart.getSourceLocation()); if (thisJoinPoint.getArgs()[0].equals("Laurie")) System.out.println("Laurie wins 1 million pounds!"); } }</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java</file><file>runtime/testsrc/RuntimeModuleTests.java</file><file>runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java</file></fixedFiles></bug><bug commit="851da68" fixdate="1092050000" id="71377" opendate="1091630000" status="resolved fixed"><buginformation><summary>71377 Cannot advise private method call in around advice</summary><description>Pointcuts should match call joint points in advice. However AspectJ does not match calls to _private_ methods in around advice. The same applies to get/set pointcuts for _private fields. This is probably because in the testcase below a call to "privateMethod()" in the body of the around advice is a call to an accessor method: ajc$inlineAccessMethod$bug_nnnn_JoinPointInAroundAdvice$bug_nnnn_JoinPointInAro undAdvice$privateMethod("around"); public aspect JoinPointInAroundAdvice { private static Set privateCalls = new HashSet(); private static Set publicCalls = new HashSet(); pointcut internalCall () : call(* JoinPointInAroundAdvice.privateMethod(..)); before () : internalCall () { privateCalls.add(thisJoinPoint); } pointcut externalCall () : call(* JoinPointInAroundAdvice.publicMethod(..)); before () : externalCall () { publicCalls.add(thisJoinPoint); } pointcut execTest () : execution(* JoinPointInAroundAdvice.test()); before () : execTest () { privateMethod("before"); publicMethod("before"); } void around () : execTest () { privateMethod("around"); publicMethod("around"); proceed(); } // void around () : execTest () { // Runnable runnable = new Runnable () { // public void run () { // privateMethod("around closure"); // publicMethod; // proceed(); // } // }; // runnable.run(); // } after () : execTest () { privateMethod("after"); publicMethod("after"); } private static void privateMethod (String from) { System.out.println("? privateMethod() " + from); } public static void publicMethod (String from) { System.out.println("? publicMethod() " + from); } public static void test () { System.out.println("? test()"); privateMethod("test"); publicMethod("test"); } public static void main (String[] args) { test(); if (privateCalls.size() != publicCalls.size()) { throw new RuntimeException("Missing join point"); } else { System.out.println("Success."); } } }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file><file>tests/bugs/AroundAdviceJPs/FieldGetJoinPointsInAroundAdvice.java</file><file>tests/bugs/AroundAdviceJPs/FieldJoinPointsInAroundAdvice.java</file><file>tests/bugs/AroundAdviceJPs/JoinPointInAroundAdvice.java</file><file>tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java</file></fixedFiles></bug><bug commit="061395c" fixdate="1091800000" id="44191" opendate="1065310000" status="resolved fixed"><buginformation><summary>44191 Need better error message for "can't find type"</summary><description>I have experienced situations where IAJC outputs a message like this at the end of compilation. [iajc] can't find type org.xxx.SomeTest In my case this was one time highly confusing since I did not expect the class in question to be referred anywhere in the project (I have to date still not located the reference). For such cases, it would be extremely nice if the error message would display WHY it need the class (i.e. the name of the refering class(es) or aspect(es) possibly with a reasonable cutoff as there is seldom need to list all referals). So I would like a message like this: [iajc] can't find type org.xxx.SomeTest referred by org.yyy.SomeClass,org.yy.SomeOtherClass ...</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareParents.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java</file></fixedFiles></bug><bug commit="648c0f4" fixdate="1091730000" id="42573" opendate="1062720000" status="resolved fixed"><buginformation><summary>42573 .lst file entries not resolved relative to list file: {boot}classpath, extdirs,</summary><description>My -classpath entry in a config/.lst file was resolved relative to the working directory rather than to the config/.lst file. BuildArgParser.java looks like this would also be true for bootclasspath and extdirs, but not for injars, aspectpath, or sourceroots.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java</file><file>util/src/org/aspectj/util/ConfigParser.java</file></fixedFiles></bug><bug commit="ef7885f" fixdate="1091540000" id="60015" opendate="1083010000" status="resolved fixed"><buginformation><summary>60015 NPE, Incorrect XLint:unmatchedSuperTypeInCall warning</summary><description>(This is an incomplete bug report -- sorry no time not to further isolate.) Running AJDT 1.1.6, I get dozens of these warnings: ---------- Warning does not match because declaring type is java.lang.Object, if match desired use target(st.ata.mc.exim.DatastoreReader) [Xlint:unmatchedSuperTypeInCall] Blah.aj project/src/package/dir line 22 ---------- for something like this code: ---------- import pack.Interface; ... pointcut dsrCall() : call(* Interface.*(..)); // WARNING HERE ... ---------- Each warning points to the pointcut (not the join point shadow). NPE running from the command-line with the latest tree (will attach).</description></buginformation><fixedFiles><file>tests/bugs/IncorrectXlintOnInterface.java</file><file>weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java</file></fixedFiles></bug><bug commit="2b8fa31" fixdate="1091460000" id="57666" opendate="1081290000" status="resolved fixed"><buginformation><summary>57666 duplicate manifests cause resource-copying to gack</summary><description>(Ah, the joy of build infrastructure...) Mostly self-explanatory trace, from a build Monday Apr 5, 2004 at 08:46:01 GMT: duplicate entry: META-INF/MANIFEST.MF duplicate entry: META-INF/MANIFEST.MF java.util.zip.ZipException: duplicate entry: META-INF/MANIFEST.MF at java.util.zip.ZipOutputStream.putNextEntry(ZipOutputStream.java:163) at java.util.jar.JarOutputStream.putNextEntry(JarOutputStream.java:90) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.writeResource(AjBuildManager.java:344) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesFromJarFile(AjBuildManager.java:288) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.copyResourcesToDestination(AjBuildManager.java:253) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:195) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79)</description></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/DuplicateManifestTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file></fixedFiles></bug><bug commit="7f19ab4" fixdate="1091450000" id="67774" opendate="1087550000" status="resolved fixed"><buginformation><summary>67774 Nullpointer-exception in pointcuts using withincode() clause</summary><description>Hi, I am getting null-pointer-exceptions whenever I try to specify a pointcut with a "withincode(Signature)" clause. E.g.: public aspect DetectSystemOutErrorUsage { pointcut allSystemOutAndSystemErrAccesses(): (get(* System.out) || get(* System.err)) ; declare warning: allSystemOutAndSystemErrAccesses() &amp;&amp; !adviceexecution() &amp;&amp; !within(com.tivoli.act..Test*) &amp;&amp; !within(com.tivoli.act.log..*) &amp;&amp; !execution(* com.tivoli.act..*.main(..)) &amp;&amp; !execution(* com.tivoli.act..*.usage()) // &amp;&amp; !withincode(* com.tivoli.act..*.main(..)) // &amp;&amp; !withincode(* com.tivoli.act..*.usage()) : "Warning: use of System.out or System.err - consider logging instead!"; } In the above example excluding main() and usage() methods from the pointcut using an execution(...)-clause (shows) works but using a withincode()-clause (as commented) always yields an NPE: trouble in: null java.lang.NullPointerException at org.aspectj.weaver.patterns.SignaturePattern.matches (SignaturePattern.java:87) at org.aspectj.weaver.patterns.WithincodePointcut.match (WithincodePointcut.java:42) at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62) at org.aspectj.weaver.Checker.match(Checker.java:48) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:1121) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit (BcelClassWeaver.java:895) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:793) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:343) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:80) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump (BcelWeaver.java:689) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:615) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:601) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:108) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165) !SESSION Jun 18, 2004 10:49:48.666 --------------------------------------------- eclipse.buildId=I200406110010 java.version=1.4.2_03 java.vendor=Sun Microsystems Inc. BootLoader constants: OS=win32, ARCH=x86, WS=win32, NL=de_CH !ENTRY org.eclipse.ajdt.ui 4 0 Jun 18, 2004 10:49:48.666 !MESSAGE NullPointerException thrown: null !STACK 0 java.lang.NullPointerException at org.aspectj.weaver.patterns.SignaturePattern.matches (SignaturePattern.java:87) at org.aspectj.weaver.patterns.WithincodePointcut.match (WithincodePointcut.java:42) at org.aspectj.weaver.patterns.NotPointcut.match(NotPointcut.java:45) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.patterns.AndPointcut.match(AndPointcut.java:42) at org.aspectj.weaver.ShadowMunger.match(ShadowMunger.java:62) at org.aspectj.weaver.Checker.match(Checker.java:48) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:1121) at org.aspectj.weaver.bcel.BcelClassWeaver.matchInit (BcelClassWeaver.java:895) at org.aspectj.weaver.bcel.BcelClassWeaver.match (BcelClassWeaver.java:793) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:343) at org.aspectj.weaver.bcel.BcelClassWeaver.weave (BcelClassWeaver.java:80) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:724) at org.aspectj.weaver.bcel.BcelWeaver.weaveWithoutDump (BcelWeaver.java:689) at org.aspectj.weaver.bcel.BcelWeaver.weaveAndNotify (BcelWeaver.java:615) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:563) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave (AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling (AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:601) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:94) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:108) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165) Michael</description></buginformation><fixedFiles><file>tests/bugs/WithincodeNPE01.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="9aed31d" fixdate="1091440000" id="70773" opendate="1090630000" status="resolved fixed"><buginformation><summary>70773 AspectJ Error: ConncurrentModificationException thrown: null</summary><description>In AspectJ 1.1.11 for Eclipse, build ID 1.2.0 (and also in the previous 1.1.10) on Eclipse version 3.0.0, build ID 200406351208: If I enable incremental compilation and make a change to a file (typing a space and deleting it, or editing a comment), I get a "ConncurrentModificationException thrown: null" error.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file></fixedFiles></bug><bug commit="4feb835" fixdate="1091110000" id="30439" opendate="1043790000" status="resolved fixed"><buginformation><summary>30439 spurious "circular dependency" error</summary><description>AspectJ Compiler 1.1beta4 This program: aspect Foo { pointcut p1(): execution(void f()) &amp;&amp; cflow(execution(void f1())); pointcut p2(): execution(void f()) &amp;&amp; cflow(execution(void f2())); before(): p1() { } after(): p1() { } before(): p2() { } after(): p2() { } } class A { void f1() { f(); } void f2() { f(); } void f() { } } results in these errors: circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) circular dependency at method-execution(void A.f()) 4 errors If I comment out any one of the four pieces of advice, all the errors go away. Also, assuming that there is a valid reason for printing this error sometimes, how come there's no line number? --Doug</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/Advice.java</file><file>weaver/src/org/aspectj/weaver/Lint.java</file><file>weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file><file>weaver/src/org/aspectj/weaver/WeaverMessages.java</file><file>weaver/src/org/aspectj/weaver/WeaverStateInfo.java</file><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file><file>weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file><file>weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareParents.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/TypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file><file>weaver/testsrc/org/aspectj/weaver/BcweaverTests.java</file><file>weaver/testsrc/org/aspectj/weaver/WeaverMessagesTestCase.java</file></fixedFiles></bug><bug commit="45bce91" fixdate="1091100000" id="61536" opendate="1084120000" status="resolved fixed"><buginformation><summary>61536 Front-end bug, shouldn't allow patterns of the form foo.., should be foo..*</summary><description>See following code: public class Test2 { public static void main(String args[]) { System.out.println("Hi"); } } aspect Aspect2 { // shouldn't one have to say, java..* instead of java.. in the following?? // Note that the first advice (incorrect one) passes the front-end, but does // not match, whereas the second one does match. I believe the front-end // should reject the first one. before () : call( * java..(..)) &amp;&amp; within(Test2) { System.out.println( "Incorrect One: Before a call of method in a java package "); } before () : call( * java..*(..)) &amp;&amp; within(Test2) { System.out.println( "Correct One: Before a call of method in a java package "); } }</description></buginformation><fixedFiles><file>tests/bugs/EllipsesStar.java</file><file>weaver/src/org/aspectj/weaver/patterns/PatternParser.java</file></fixedFiles></bug><bug commit="10c6de6" fixdate="1091030000" id="48990" opendate="1071660000" status="resolved fixed"><buginformation><summary>48990 Special case if(false) to not require a dynamic test</summary><description>FastMatch, the efficient pattern matching for pointcuts on the constant pool, is currrently only implemented for the within pointcut. I am planning to provide further oimplementations for other pointcuts by release 1.2.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/Pointcut.java</file></fixedFiles></bug><bug commit="573741c" fixdate="1091030000" id="64331" opendate="1085670000" status="resolved fixed"><buginformation><summary>64331 java.lang.NullPointerException in WeaverMessageHandler class</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java</file><file>tests/bugs/abstractITDs/A.java</file><file>tests/bugs/abstractITDs/C.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file></fixedFiles></bug><bug commit="6ea8300" fixdate="1090940000" id="58681" opendate="1082050000" status="resolved fixed"><buginformation><summary>58681 -X should output available -X options</summary><description>ajc should emit the available -X options on -help or -X request (the latter like java) to get more traffic and feedback on the experimental options.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java</file><file>org.aspectj.ajdt.core/testsrc/EajcModuleTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java</file></fixedFiles></bug><bug commit="b184363" fixdate="1090940000" id="69459" opendate="1089210000" status="resolved fixed"><buginformation><summary>69459 Hiding of Instance Methods by static methods</summary><description>Using Introduction it is possible to hide instance methods by static methods. Example: class Super { public void m(){}; } class Sub {} aspect A { public static void Sub.m(){} } Acccording to the Java Language Specification this is not allowed. Is this behaviour desired ?? It is also possible to override static methods by instance methods, wich causes a compile time error in java.</description></buginformation><fixedFiles><file>tests/bugs/intertypeOverrides/Aspect1.java</file><file>tests/bugs/intertypeOverrides/Aspect2.java</file><file>tests/bugs/intertypeOverrides/IntertypeOverrides.java</file><file>tests/bugs/intertypeOverrides/IntertypeOverrides2.java</file><file>tests/bugs/intertypeOverrides/Subclass.java</file><file>tests/bugs/intertypeOverrides/Superclass.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file></fixedFiles></bug><bug commit="936459c" fixdate="1090920000" id="53999" opendate="1078720000" status="resolved fixed"><buginformation><summary>53999 "can't bind type" message has $ for . in type name for declare soft</summary><description>cosmetic mistake in error message... expected: can't bind type name 'unknown.Error' actual: can't bind type name 'unknown$Error' (not sure why it would ever be munged with $) public class Test { public static void main(String[] args) { test(); } static void test() { throw new Error("hello"); } static aspect A { declare soft : unknown.Error : call(void test()); // CE } }</description></buginformation><fixedFiles><file>tests/bugs/Cosmetic.java</file><file>weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java</file></fixedFiles></bug><bug commit="75852d7" fixdate="1090850000" id="70619" opendate="1090510000" status="resolved fixed"><buginformation><summary>70619 compiler aborts with "conflicting dominates orders" with circular declare precedences</summary><description>The following program causes ajc 1.2 to abort: public class Conflict { public static void main(String[] args) { } } aspect Conflict1 { declare precedence: Conflict1, Conflict2; before(): execution(* *(..)) { } } aspect Conflict2 { declare precedence: Conflict2, Conflict1; after(): execution(* *(..)) { } }</description></buginformation><fixedFiles><file>tests/bugs/bug70619/Conflict.java</file><file>tests/bugs/bug70619/Precedence.java</file><file>weaver/src/org/aspectj/weaver/World.java</file></fixedFiles></bug><bug commit="8dc0845" fixdate="1089840000" id="70008" opendate="1089800000" status="resolved fixed"><buginformation><summary>70008 problem with ajdoc -public</summary><description /></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java</file><file>ajdoc/testdata/coverage/foo/PkgVisibleClass.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java</file></fixedFiles></bug><bug commit="2cc4826" fixdate="1089050000" id="69011" opendate="1088610000" status="resolved fixed"><buginformation><summary>69011 ajdoc fails when using default package</summary><description /></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java</file><file>ajdoc/testdata/coverage/InDefaultPackage.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file></fixedFiles></bug><bug commit="3707411" fixdate="1088120000" id="68494" opendate="1088090000" status="resolved fixed"><buginformation><summary>68494 ajdoc does not support .aj files</summary><description>In addition to accepting .java source files ajdoc needs to accept .aj files.</description></buginformation><fixedFiles><file>ajdoc/src/org/aspectj/tools/ajdoc/Main.java</file><file>ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java</file><file>ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java</file><file>ajdoc/testdata/coverage/foo/UseThisAspectForLinkCheck.java</file><file>ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java</file></fixedFiles></bug><bug commit="39c3a3b" fixdate="1085760000" id="61411" opendate="1083950000" status="resolved fixed"><buginformation><summary>61411 AJDoc launch script on Windows can lose arguments</summary><description>Using AspectJ 1.2rc1 on Windows XP This report highlights a problem that I've seen using ajdoc.bat on Windows but the issue applies equally to the ajc.bat and ajbrowser.bat files as well. The %ASPECTJ_HOME%\bin\ajdoc.bat file that users run to launch the ajdoc tool imposes a limit of only 9 command line arguments that may be passed to the class org.aspectj.tools.ajdoc.Main. In scenarios where there the -sourcepath, -classpath, -d etc options are used it is easy for these to "eat up" the list of arguments that are passed into the JVM. A long list of packages entered at the end of the ajdoc.bat command can be truncated or possibly even ignored (in which case an error message will be output telling the user that no classes or packages have been specified). In order to prevent a limit being put on the number of arguments passed to the launched JVM, the invocation line needs to end with %* rather than the %1 %2 %3 %4 %5 %6 %7 %8 %9 list it currently uses. The proposed fix also *seems* (could somebody else confirm this ?) to sort out another problem regarding the ajdoc.bat file which is this : long semi- colon delimited paths supplied as the arguments for the -sourcepath and -classpath options seem to get split apart and passed into the JVM as separate arguments unless the entire path list is supplied inside quotes. This should not be necessary. It seems that the batch file processor interprets the semi-colons in a path list as delimiters between arguments. Consequently each element in the path list is treated as a separate argument instead of being part of one big string representing the sourcepath or classpath.</description></buginformation><fixedFiles><file>build/src/$installer$/org/aspectj/Main.java</file></fixedFiles></bug><bug commit="9ebfc84" fixdate="1084540000" id="62227" opendate="1084530000" status="resolved fixed"><buginformation><summary>62227 Load Time Weaving aborts on any kind of warning (declare/xlint)</summary><description>The message handler in the weaving adapter for load time weaving says: public boolean handleMessage(IMessage message) throws AbortException { if (!isIgnoring(message.getKind())) { if (verbose) System.err.println(message.getMessage()); throw new AbortException(message); } return true; } This means for warnings it goes bang. So, even a declare warning that is meant to tell the user something informational during a LTW will cause the code to blow up. The fix is straightforward and simply to log warning messages and only fail for error messages. I am waiting for a testcase from Matthew before checking in the fix.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java</file><file>weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file><file>weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java</file></fixedFiles></bug><bug commit="5f6b18b" fixdate="1083750000" id="59909" opendate="1082970000" status="resolved fixed"><buginformation><summary>59909 CFlowStack removesThreads to late</summary><description>Problem: The current implementation of CFlowStack (Version 1.1-till 1.2 rc1) stores all threads in a hashtable. These Threads are removes after several calls to the methods getThreadStack(). (In our cases &gt;70 calls.) In our project, this cycle is much to long. We have soveral long running threads, which grap quite a lot of lot of memory. This memory can only be freed after the threads have been removed from the CFlowStack. In our production code we sum up to more than 300 Threads stored in different CFlowStack Varaibles. Often this results in out of memory Errors. Added patch provides an improved freeing scheme. It checks if the size of the table has grown, if it has, it checks if it can remove some threads.</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/runtime/internal/CFlowStack.java</file><file>runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStack.java</file><file>runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactory.java</file><file>runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl.java</file><file>runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackFactoryImpl11.java</file><file>runtime/src/org/aspectj/runtime/internal/cflowstack/ThreadStackImpl11.java</file></fixedFiles></bug><bug commit="a97f3b6" fixdate="1082740000" id="59596" opendate="1082630000" status="resolved fixed"><buginformation><summary>59596 Null pointer exception while weaving java.awt.Label</summary><description>I tried to add an Aspect to java.awt.Label. I compile the aspect via: ajc -inpath /usr/local/j2sdk_nb/j2sdk1.4.2/jre/lib/rt.jar Timestamp.java Here is the aspect Timestamp.java: aspect Timestamp { private int java.awt.Label._ts_read = 0; private int java.awt.Label._ts_write = 0; pointcut writeOp(): call (void java.awt.Label.setText (String)); pointcut readOp(): call (String java.awt.Label.getText()); after (java.awt.Label b) returning: readOp() &amp;&amp; target (b) { b._ts_read++; } after (java.awt.Label b) returning: writeOp() &amp;&amp; target (b) { b._ts_write++; System.out.println (b._ts_write); } public static void main (String[] args) { java.awt.Label b1 = new java.awt.Label(); b1.setText ("abc"); } } Here is the error message I get from ajc: null java.lang.NullPointerException at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeLocationContext(EclipseAdapterUtils.java:50) at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeSourceLocation(EclipseAdapterUtils.java:120) at org.aspectj.ajdt.internal.core.builder.EclipseAdapterUtils.makeMessage(EclipseAdapterUtils.java:129) at org.aspectj.ajdt.internal.core.builder.AjBuildManager$4.acceptResult(AjBuildManager.java:663) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.acceptResult(AjCompilerAdapter.java:178) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.finishedWith(WeaverAdapter.java:203) at org.aspectj.ajdt.internal.compiler.WeaverAdapter.weaveCompleted(WeaverAdapter.java:167) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:570) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.weave(AjCompilerAdapter.java:239) at org.aspectj.ajdt.internal.compiler.AjCompilerAdapter.afterCompiling(AjCompilerAdapter.java:114) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:376) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation(AjBuildManager.java:600) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild(AjBuildManager.java:160) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild(AjBuildManager.java:94) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:102) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:280) at org.aspectj.tools.ajc.Main.runMain(Main.java:217) at org.aspectj.tools.ajc.Main.main(Main.java:79) 1 fail|abort</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java</file></fixedFiles></bug><bug commit="b0d32ca" fixdate="1081420000" id="57436" opendate="1081160000" status="resolved fixed"><buginformation><summary>57436 Java 1.5 fails to run classes produced by ajc</summary><description>Java 1.5 beta reports a ClassFormatError when running programs (e.g., spacewar) compiled by ajc 1.1.1 and the latest CVS head. Sun's Java 1.5 beta binary-compatibility docs say that some obfuscators violated the .class format specification, so those .class files will fail when run under 1.5. (The docs also say they are still incomplete.) Although 1.5 is still beta, we would want to submit a bug to Sun if our implementation techniques are valid, so we don't have to change those techniques. For 1.2, we should at document if we don't fix, since many people are using 1.5.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file></fixedFiles></bug><bug commit="e7ac54f" fixdate="1081330000" id="57430" opendate="1081160000" status="resolved fixed"><buginformation><summary>57430 exception printing</summary><description>Exceptions thrown from the compiler used to be printed once, with the submit-bug header. Now they are printed twice, without and with the header. True of CVS version.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java</file></fixedFiles></bug><bug commit="0521e79" fixdate="1080910000" id="55341" opendate="1079690000" status="resolved fixed"><buginformation><summary>55341 error Type mismatch: cannot convert from java.lang.String to java.lang.String</summary><description>When compiling a binary concrete aspect library (for later LTW) consisting of more than one aspect that performs an ITD on a target class not exposed to the weaver I get the following error: error Type mismatch: cannot convert from java.lang.String to java.lang.String The error does not oocur if a complete build &amp; weave is performed. Testcase attached.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java</file><file>tests/bugs/StringToString/HW.java</file><file>tests/bugs/StringToString/X.java</file><file>weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java</file></fixedFiles></bug><bug commit="33d8ee9" fixdate="1080910000" id="31460" opendate="1044890000" status="resolved fixed"><buginformation><summary>31460 Weaving class loader</summary><description>Hi! As discussed on the mailing list a few days ago I implemented a weaving class loader to enable bytecode based weaving at class loading time. The class loader is based on the URLClassLoader and can be used like any other URLClassLoader. In addition to that you can add aspects to the weaving loader. These aspects got woven into each class that is loaded. The test cases for the class loader aren't implemented yet, I am still thinking about how to implement them. I will contribute them later, okay? -Martin</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/testdata/src1/LTWHelloWorld.java</file><file>org.aspectj.ajdt.core/testdata/src1/ltw/LTWPackageTest.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java</file><file>util/src/org/aspectj/util/FileUtil.java</file><file>weaver/src/org/aspectj/weaver/ExtensibleURLClassLoader.java</file><file>weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java</file><file>weaver/src/org/aspectj/weaver/tools/GeneratedClassHandler.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java</file><file>weaver/src/org/aspectj/weaver/tools/WeavingClassLoader.java</file><file>weaver/testsrc/BcweaverModuleTests.java</file><file>weaver/testsrc/org/aspectj/weaver/BcweaverTests.java</file><file>weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java</file></fixedFiles></bug><bug commit="0a01759" fixdate="1079690000" id="53012" opendate="1077670000" status="resolved fixed"><buginformation><summary>53012 declare precedence on a class should be a compile-time error</summary><description>The compiler silently accepts ---- public class DeclarePrecedence { public static void main(String[] args) { System.out.println("hello"); } } aspect DP { declare precedence: DeclarePrecedence, DP; before() : staticinitialization(DeclarePrecedence) { System.out.println("ok"); } } ---- Since this is likely to be a mistake, an error would be nice. However, that would mean saying (!TargetClass &amp;&amp; TargetClass+) to pick out the aspect subtypes of TargetClass.</description></buginformation><fixedFiles><file>tests/bugs/declarePrecedenceWithClasses/DeclarePrecedenceTestClass.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java</file></fixedFiles></bug><bug commit="183fc23" fixdate="1079610000" id="40192" opendate="1058350000" status="resolved fixed"><buginformation><summary>40192 build cancel during weaving</summary><description>The build can not be cancelled during the bytecode weaving stage.</description></buginformation><fixedFiles><file>ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java</file><file>ajde/testdata/BuildCancelling/Cl1.java</file><file>ajde/testdata/BuildCancelling/Cl2.java</file><file>ajde/testdata/BuildCancelling/Cl3.java</file><file>ajde/testdata/BuildCancelling/HW.java</file><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/BuildCancellingTest.java</file><file>bridge/src/org/aspectj/bridge/IProgressListener.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file></fixedFiles></bug><bug commit="34dbb0c" fixdate="1079530000" id="47910" opendate="1070390000" status="resolved fixed"><buginformation><summary>47910 ajc -outjar jarfile does not contain MANIFEST.MF</summary><description>I call ajc -sourceroots &lt;mydir&gt; -outjar &lt;my.jar&gt; and an output file is created with a .jar extension, but it is not a valid jar file because there is no MANIFEST.MF file. I see that the text for ajc says: -outjar &lt;file&gt; put output classes in zip file &lt;file&gt; which might imply that it is supposed to be a zip file, but a parameter called - outjar which creates a zip file doesn't really make sense. If -outjar is used, the resulting file should be a valid jar file, i.e. with a META-INF/MANIFEST.MF file inside.</description></buginformation><fixedFiles><file>ajde/testdata/JarManifestTest/src/Main.java</file><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/InpathTestcase.java</file><file>ajde/testsrc/org/aspectj/ajde/JarManifestTest.java</file><file>ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file></fixedFiles></bug><bug commit="1a4c02c" fixdate="1079450000" id="54625" opendate="1079100000" status="resolved fixed"><buginformation><summary>54625 Incremental support does not work with outjar</summary><description>Either fix the class file deleting etc. to work with jars, or always do a batch build when working with outjars.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java</file></fixedFiles></bug><bug commit="41c6f6d" fixdate="1079450000" id="54965" opendate="1079450000" status="resolved fixed"><buginformation><summary>54965 Incremental compilation does twice as much work as necessary</summary><description>When I added support for -outjar in the test harness, I was surprised to find duplicate entry exceptions coming from the output file writing to the outjar. I traced it through, and found that every source file passed to an incremental compile is in fact compiled twice! The first time round we note the references, and of course each file has a reference to itself. Then we call "AjState.getFilesToCompile" looking to see if there are any further files to compile in another iteration. This method does not remember the set of files it just compiled, so since we have referenced each type we just compiled, and we have no reord of that fact, we compile them again. Second time around, the bytecodes are identical to the previous go, so recordClassFile doesn't note their dependents - and thus this time we terminate.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java</file></fixedFiles></bug><bug commit="5c67166" fixdate="1079390000" id="51322" opendate="1076190000" status="resolved fixed"><buginformation><summary>51322 Introduce Unknown Type to class causes Null pointer exception</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java</file><file>tests/bugs/Pr51322.java</file></fixedFiles></bug><bug commit="0109534" fixdate="1079370000" id="44272" opendate="1065500000" status="resolved fixed"><buginformation><summary>44272 retitle warning to "circular {advice} dependency at ..."</summary><description>When writing aspects with cycles in the advice precedence, get warning "circular dependency at {join point}" -- should be "circular advice dependency..." or "circular advice precedences at {join point} -- reorder the advice in the aspect". FWIW, here's an example of circularity in advice precedence: ---- aspect A { pointcut crun() : execution (void run()) ; before() : crun() {} after() returning : crun() {} void around() : crun() { proceed(); } } ---- See programming guide for more discussion of circularity in advice precedence.</description></buginformation><fixedFiles><file>tests/bugs/CircularAdvicePrecedence.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file><file>weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java</file></fixedFiles></bug><bug commit="c798923" fixdate="1078480000" id="50776" opendate="1075310000" status="resolved fixed"><buginformation><summary>50776 fail in compiling aspect with overriding method introduction with different throws clause</summary><description>A first class (class A) declares only one method with some exceptions in the throws clause ( void m() throws Exception ). A second class (class B) extends it without redefinig the method. An aspect declares a method introduction in the class B, with the same name, signature and return type of the one in class A, but without throws clause; this is a legal override. In the second class (class B) each invocation to the overriden method doesn't need a try-catch block, because it refers to his hown method that raises no exception. This code compiles using ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.0 But not using AspectJ Compiler 1.1.1 AspectJ Compiler 1.1.0 class A{ public A(){} public void m() throws Exception{} } class B extends A{ public B(){} public void some_code(){ m();} } aspect C{ public void B.m(){} }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java</file><file>tests/bugs/IntertypeDifferentThrows.java</file></fixedFiles></bug><bug commit="5d73494" fixdate="1078420000" id="52394" opendate="1077130000" status="resolved fixed"><buginformation><summary>52394 inter-type declarations cause JRockit Crash</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java</file></fixedFiles></bug><bug commit="fbc0aa3" fixdate="1077710000" id="51320" opendate="1076170000" status="resolved fixed"><buginformation><summary>51320 ClasscastException on concretization of if(false)</summary><description>I get the following exception when weaving the attached aspect on the dev build. java.lang.ClassCastException at org.aspectj.weaver.patterns.IfPointcut.concretize1(IfPointcut.java:156) at org.aspectj.weaver.patterns.IfPointcut.concretize(IfPointcut.java:143) at org.aspectj.weaver.patterns.Pointcut.concretize(Pointcut.java:119) at org.aspectj.weaver.Checker.concretize(Checker.java:35) at org.aspectj.weaver.CrosscuttingMembers. addShadowMunger(CrosscuttingMembers.java:78) at org.aspectj.weaver.CrosscuttingMembers.addDeclare(CrosscuttingMembers. java:102) at org.aspectj.weaver.CrosscuttingMembers.addDeclares(CrosscuttingMembers. java:92) at org.aspectj.weaver.CrosscuttingMembersSet. addAdviceLikeDeclares(CrosscuttingMembersSet.java:65) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment. addAdviceLikeDeclares(AjLookupEnvironment.java:147) at org.aspectj.ajdt.internal.compiler.lookup.AjLookupEnvironment. completeTypeBindings(AjLookupEnvironment.java:122) at org.eclipse.jdt.internal.compiler.Compiler.beginToCompile(Compiler.java: 300) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:314) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. performCompilation(AjBuildManager.java:384) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. doBuild(AjBuildManager.java:125) at org.aspectj.ajdt.internal.core.builder.AjBuildManager. batchBuild(AjBuildManager.java:70) at org.aspectj.ajdt.ajc.AjdtCommand.doCommand(AjdtCommand.java:104) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(AjdtCommand.java:53) at org.aspectj.tools.ajc.Main.run(Main.java:234) at org.aspectj.tools.ajc.Main.runMain(Main.java:170) at org.aspectj.tools.ajc.Main.main(Main.java:81)</description></buginformation><fixedFiles><file>tests/bugs/DecwClassCastException.java</file><file>weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java</file></fixedFiles></bug><bug commit="16a0abd" fixdate="1077630000" id="36430" opendate="1050220000" status="resolved fixed"><buginformation><summary>36430 Support -Xreweavable option</summary><description /></buginformation><fixedFiles><file>ajde/testdata/ReweavableTest/CalculatePI.java</file><file>ajde/testdata/ReweavableTest/tjp/Demo.java</file><file>ajde/testdata/ReweavableTest/tjp/GetInfo.java</file><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/ReweavableTestCase.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java</file><file>testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java</file><file>weaver/src/org/aspectj/weaver/Advice.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembers.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file><file>weaver/src/org/aspectj/weaver/WeaverStateInfo.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java</file><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file></fixedFiles></bug><bug commit="6ddae42" fixdate="1077230000" id="51929" opendate="1076640000" status="resolved fixed"><buginformation><summary>51929 Advice calling protected super method causing java.lang.VerifyError 'Bad access to protected data'</summary><description>A java.lang.VerifyError is thrown at runtime complaining about 'Bad access to protected data' when advice, on a sub-aspect, that calls a protected method, on the super-aspect, is woven into a class. However another call to the same method woven into the same class but due to advice declared in the super-aspect works fine. The aspects were woven into precompiled (by sun's 1.4 javac) classes. The verify error occurs under both sun's 1.4 and blackdowns 1.3 VMs, and presumably all VMs. Workaround: Making the protected method public fixes the verify error. A test case is available in CVS: tests/bugs/protectedvf/... tests/ajcTestFailing.xml</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java</file><file>tests/bugs/protectedvf/main/Driver.java</file></fixedFiles></bug><bug commit="669cd7c" fixdate="1077210000" id="45489" opendate="1066990000" status="resolved fixed"><buginformation><summary>45489 Structure model is wrong when re-opened</summary><description>Some elements have the wrong kinds when a saved structure model is loaded. E.g. if I close then re-open the eclipse workbench classes are shown as interface in the outline view. Also if I traverse the tree with the code below I get the wrong kinds assigned to classed, interfaces, aspects and import declarations. List list = StructureModelUtil.getPackagesInModel(); for(Iterator i = list.iterator(); i.hasNext();){ Object[] o = (Object[])i.next(); IProgramElement node = (IProgramElement)o[0]; List files = StructureModelUtil.getFilesInPackage(node); for(Iterator i2 = files.iterator(); i2.hasNext();){ IProgramElement file = (IProgramElement)i2.next (); System.out.println("file " + file.getKind ().toString() + ", " + file.getName()); boolean added2 = false; List file_children = file.getChildren(); // file children can be classes, aspects or other things for(Iterator i3 = file_children.iterator(); i3.hasNext();){ IProgramElement file_child = (IProgramElement)i3.next(); System.out.println("kind: " + file_child.getKind().toString() +", " + file_child.getName());</description></buginformation><fixedFiles><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/SavedModelConsistencyTest.java</file><file>asm/src/org/aspectj/asm/IProgramElement.java</file></fixedFiles></bug><bug commit="19bac86" fixdate="1075250000" id="50570" opendate="1075050000" status="resolved fixed"><buginformation><summary>50570 CatchClauseSignature has broken operation</summary><description>It looks like the getParameterName() operation on org.aspectj.lang.reflect. CatchClauseSignature is not working. Instead of returning the name of the exception as declared in the matched handler, returns the string value "&lt;missing&gt;". Here is a test case that shows the problem :- ------START OF TEST CASE CODE----------- public class MyApp { public void doSomething() { // Get around "unreachable code error... if (true) { throw new BusinessException("Surprise!!"); } System.out.println("Busy doing something."); } public static void main(String[] args) { try { MyApp m = new MyApp(); m.doSomething(); } catch (BusinessException be) { System.out.println("Exception caught : " + be.getMessage()); } } } class BusinessException extends RuntimeException { BusinessException(String message) { super(message); } } aspect AppMonitor { pointcut problemHandling() : handler(Throwable+); before() : problemHandling() { CatchClauseSignature cSig = (CatchClauseSignature) thisJoinPointStaticPart.getSignature(); System.out.println( "MONITOR::\tCaught a " + cSig.getParameterType().getName() + " called " + cSig.getParameterName()); } } ------END OF TEST CASE CODE----------- The output from running the above was ... MONITOR:: Caught a BusinessException called &lt;missing&gt; Exception caught : Surprise !!!! Operating system : Windows XP AspectJ : 1.1.1 final and also on latest from CVS HEAD</description></buginformation><fixedFiles><file>tests/bugs/HandlerSig.java</file><file>weaver/src/org/aspectj/weaver/Member.java</file><file>weaver/src/org/aspectj/weaver/ResolvedMember.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="0c83343" fixdate="1074910000" id="48091" opendate="1070560000" status="resolved fixed"><buginformation><summary>48091 Lazy instantiation of thisJoinPoint</summary><description>In cases where the body of advice refers to a non-statically evaluable portion of thisJoinPoint (so that it can't be optimized by the compiler to thisJoinPointStaticPart), the JoinPoint object is currently always created before entering the advice body - even if the JoinPoint object would never actually be accessed (because of a test within the advice for example). Since a) thisJoinPoint is often used in tracing applications b) tracing applications tend to be very pervasive, c) they must have low overhead when tracing is disabled, and d) creation of thisJoinPoint objects is expensive (v. expensive compared to just testing a flag) it would be nice if there was a way to create JoinPoint objects lazily on first actual reference within the advice body.</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/PerformanceTestCase.java</file><file>runtime/src/org/aspectj/runtime/reflect/Factory.java</file><file>weaver/src/org/aspectj/weaver/Lint.java</file><file>weaver/src/org/aspectj/weaver/World.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="6f099df" fixdate="1074770000" id="50200" opendate="1074510000" status="resolved fixed"><buginformation><summary>50200 aspectjrt.jar manifest file name needs changing to upper case</summary><description /></buginformation><fixedFiles><file>build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java</file></fixedFiles></bug><bug commit="b3b1eec" fixdate="1074170000" id="36234" opendate="1049830000" status="resolved fixed"><buginformation><summary>36234 out of memory error when compiling</summary><description>Getting an out of memory error when compiling with Ajc 1.1 RC1. I know this is not very descriptive, but maybe you can point me into a direction of getting more output. here some additional information though: Code base is medium size (about 1500 classfiles) I removed all my aspects and still receive the error. Running it from the command line: ajc -classpath whateveritis -sourceroots whateveritis -d whateveritis</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java</file></fixedFiles></bug><bug commit="ad2fb7a" fixdate="1074140000" id="47952" opendate="1070430000" status="resolved fixed"><buginformation><summary>47952 SoftException.printStackTrace(..) should print wrapped throwable too</summary><description>SoftExceptions should print not only their trace but also that of the wrapped throwable. We should be able to set a flag on class initialization whether we are running under 1.4 and then implement it under 1.4 using initCause() and otherwise by direct delegation. I can do this fix if we're agreed.</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/lang/SoftException.java</file><file>runtime/testsrc/RuntimeModuleTests.java</file></fixedFiles></bug><bug commit="7bbd1f4" fixdate="1074080000" id="46280" opendate="1068220000" status="resolved fixed"><buginformation><summary>46280 compiler issues error on inner aspects when privilieged</summary><description>The compiler complains that "inner aspects must be static" whenever I try to qualify an inner (and static) aspect as privileged, no matter what the enclosing type is (aspect, interface or class). I was using j2sdk1.4.0_02, AspectJ 1.1, eclipse 2.1 (with AJDT 1.1.3). Test case: ------------------ BASE CLASS: public class Capsule { private int hidden; public int visible; public Capsule(int priv, int pub) { hidden = priv; visible = pub; } public void doSomething() { System.out.println(""" + hidden + ", " + visible + """); } public static void main(String[] args) { Capsule capsule = new Capsule(1, 1); capsule.doSomething(); } } ------------------ ASPECT: public aspect Outer { static //privileged &lt;== JUST TRY TO UNCOMMENT THIS! aspect Inner { pointcut call2doSomething(Capsule capsule): call(void Capsule.doSomething()) &amp;&amp; target(capsule); before(Capsule capsule): call2doSomething(capsule) { capsule.visible++; //capsule.hidden++; } } } ------------------ INTERFACE: public interface Marker { static //privileged &lt;== JUST TRY TO UNCOMMENT THIS! aspect Inner { pointcut call2doSomething(Capsule capsule): call(void Capsule.doSomething()) &amp;&amp; target(capsule); before(Capsule capsule): call2doSomething(capsule) { capsule.visible++; //capsule.hidden++; } } }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java</file><file>tests/bugs/PrivilegedParsing.java</file></fixedFiles></bug><bug commit="7b081f2" fixdate="1073640000" id="49638" opendate="1073500000" status="resolved fixed"><buginformation><summary>49638 exception logging: after() throwing advice can't convert Throwable obj to string and ajc aborts</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java</file><file>tests/bugs/AfterThrowingAdviceSyntaxError.java</file></fixedFiles></bug><bug commit="97ab1e9" fixdate="1073490000" id="41952" opendate="1061890000" status="resolved fixed"><buginformation><summary>41952 XLint warning for call PCD's using subtype of defining type</summary><description /></buginformation><fixedFiles><file>bridge/src/org/aspectj/bridge/IMessage.java</file><file>bridge/src/org/aspectj/bridge/Message.java</file><file>bridge/src/org/aspectj/bridge/MessageUtil.java</file><file>bridge/src/org/aspectj/bridge/SourceLocation.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java</file><file>testing/src/org/aspectj/testing/xml/SoftMessage.java</file><file>tests/bugs/DeclaringTypeWarning.java</file><file>tests/new/CallTypesI.java</file><file>tests/new/IndeterminateArg.java</file><file>tests/new/IndeterminateArgType.java</file><file>weaver/src/org/aspectj/weaver/Checker.java</file><file>weaver/src/org/aspectj/weaver/Lint.java</file><file>weaver/src/org/aspectj/weaver/patterns/AndPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java</file><file>weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/NotPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/OrPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/Pointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java</file></fixedFiles></bug><bug commit="7322131" fixdate="1073490000" id="47754" opendate="1070100000" status="resolved fixed"><buginformation><summary>47754 illegal method modifier</summary><description>the attached example throws this at class load time. please note that this bug results in a different exception when happens in a different setup, and when the class is loaded by JBoss. (more cryptic, talking about generic class format error) Exception in thread "main" java.lang.ClassFormatError: com/netvisor/nvsr/client/InvalidByteCodeBug$Test$ITest (Illegal method modifiers: 0x409) at java.lang.ClassLoader.defineClass0(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:537) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java: 123) at java.net.URLClassLoader.defineClass(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(URLClassLoader.java:55) at java.net.URLClassLoader$1.run(URLClassLoader.java:194) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(ClassLoader.java:289) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274) at java.lang.ClassLoader.loadClass(ClassLoader.java:235) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302) at java.lang.ClassLoader.defineClass0(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:537) at java.security.SecureClassLoader.defineClass(SecureClassLoader.java: 123) at java.net.URLClassLoader.defineClass(URLClassLoader.java:251) at java.net.URLClassLoader.access$100(URLClassLoader.java:55) at java.net.URLClassLoader$1.run(URLClassLoader.java:194) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:187) at java.lang.ClassLoader.loadClass(ClassLoader.java:289) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:274) at java.lang.ClassLoader.loadClass(ClassLoader.java:235) at java.lang.ClassLoader.loadClassInternal(ClassLoader.java:302) at com.netvisor.nvsr.client.InvalidByteCodeBug.run(InvalidByteCodeBug. java:15) at com.netvisor.nvsr.client.InvalidByteCodeBug.main(InvalidByteCodeBug. java:8)</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java</file><file>tests/bugs/StaticInterfaceMethods.java</file></fixedFiles></bug><bug commit="eac16ae" fixdate="1073480000" id="49250" opendate="1072040000" status="resolved fixed"><buginformation><summary>49250 alias getCause for getWrappedThrowable in SoftException</summary><description>SoftException should implement getCause(): public Throwable getCause() { return inner; } (As pointed out by Ramnivas, misc mail messages, code comments...) Using getCause() means the chain should print as expected in 1.4+, esp. when SoftException is itself wrapped as a RemoteException. Since getCause() replicates getWrappedThrowable(), we could deprecate that, but we must continue to support it to maintain upwards binary compatibility in the runtime classes.</description></buginformation><fixedFiles><file>runtime/src/org/aspectj/lang/SoftException.java</file></fixedFiles></bug><bug commit="c517e85" fixdate="1073480000" id="49457" opendate="1073020000" status="resolved fixed"><buginformation><summary>49457 No error on overloaded pointcuts unless binding variables</summary><description>The compiler might not be detecting overloaded pointcut names when parameters are not bound, and/or might not be implementing the pointcut correctly. Below is the context from my reply to Ron Bodkin on aspectj-dev "Proper behavior of overloaded pointcut definitions". (I have not checked this code recently or submitted a test case, nor have I evaluated whether my code below actually replicates Ron's bug.) ---- context from the email The programming guide says, It is an error for two pointcuts to be named with the same name in the same class or aspect declaration. When I compile with overloaded pointcut names, I do get an error. pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run()); pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run()); $ aspectj-1.1.1 -classpath $ajrt11 OverloadedPointcut.java ...\OverloadedPointcut.java:14 duplicate pointcut name: pc ...\OverloadedPointcut.java:15 duplicate pointcut name: pc ... When I use these pointcuts with bound parameters, I get an error. before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } When I use these pointcuts with type parameters, I get no errors. before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } [...] ---- my code public class OverloadedPointcut { public static void main(String[] args) { new C().run(); } } class C { public void run() {} } aspect A { declare parents: C implements Runnable; declare parents: C implements SubRunnable; interface SubRunnable extends Runnable {} pointcut pc(Runnable r) : target(r) &amp;&amp; call(void run()); pointcut pc(SubRunnable r) : target(r) &amp;&amp; call(void run()); before(Runnable r) : pc(r) { log("pc(Runnable r)"); } before(SubRunnable r) : pc(r) { log("pc(SubRunnable r)"); } before() : pc(Runnable) { log("pc(Runnable)"); } before() : pc(SubRunnable) { log("pc(SubRunnable)"); } before() : pc(*) { log("pc(*)"); } void log(String s) { System.out.println(s); } } ---- Ron's code [...] the following program compiles with no warnings, produces no output when run under AspectJ 1.1.1. It appears to behave as if the more specific definition is the only definition of the pointcut [...] Here is a simple program that illustrates the question and odd behavior: package lib; public class RunnablePointcuts { public pointcut runnableCalls(Runnable runnable, Object caller) : call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller); //public pointcut specialRunnableCalls(SpecialRunnable runnable, Object caller) : public pointcut runnableCalls(SpecialRunnable runnable, Object caller) : call(* run(..)) &amp;&amp; target(runnable) &amp;&amp; this(caller); } --- package lib; public interface SpecialRunnable extends Runnable { } --- package client; import lib.RunnablePointcuts; import lib.SpecialRunnable; public aspect Use { before(Object caller) : RunnablePointcuts.runnableCalls(*, caller) &amp;&amp; target(MyRunnable) { System.out.println("my runnable called from "+caller); } public static void main(String args[]) { Use.aspectOf().doIt(); } public void doIt() { new MyRunnable().run(); } } // the advice will run if you make this implement SpecialRunnable //class MyRunnable implements SpecialRunnable { class MyRunnable implements Runnable { public void run() {} }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file><file>tests/bugs/OverloadedPointcutsInAspect.java</file><file>tests/bugs/OverloadedPointcutsInClass.java</file></fixedFiles></bug><bug commit="bdc79f1" fixdate="1069620000" id="47318" opendate="1069620000" status="resolved fixed"><buginformation><summary>47318 org.aspectj.asm.IRelationship.Kind.ALL does not contain all kinds</summary><description>org.aspectj.asm.IRelationship.Kind.ALL is an array that should contain all kinds that an IRelationship may have. There are three possible kinds defined in IRelationship.java: ADVICE, DECLARE and DECLARE_INTER_TYPE. The Kind[] ALL does only contain ADVICE and DECLARE. This can lead to an ArrayIndexOutOfBoundsException.</description></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/IRelationship.java</file></fixedFiles></bug><bug commit="3117255" fixdate="1066320000" id="44117" opendate="1065160000" status="resolved fixed"><buginformation><summary>44117 NPE on compile</summary><description>java.lang.NullPointerException at org.aspectj.weaver.AsmRelationshipProvider.checkerMunger (AsmRelationshipProvider.java:51) at org.aspectj.weaver.Checker.match(Checker.java:58) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:985) at org.aspectj.weaver.bcel.BcelClassWeaver.match(BcelClassWeaver.java:791) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:291) at org.aspectj.weaver.bcel.BcelClassWeaver.weave(BcelClassWeaver.java:77) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:417) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:390) at org.aspectj.weaver.bcel.BcelWeaver.weave(BcelWeaver.java:316) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile s(AjBuildManager.java:256) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:156) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:70) at org.aspectj.ajde.internal.CompilerAdapter.compile(CompilerAdapter.java:103) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:165)</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java</file></fixedFiles></bug><bug commit="426d89b" fixdate="1064550000" id="43709" opendate="1064530000" status="resolved fixed"><buginformation><summary>43709 structure view crash when extending library aspects</summary><description>I have an library with an aspect that includes advice, which I compile into an outjar. In my client project I extend it, and make a concrete pointcut that results in the library aspect affecting parts of my system. There is a bug and an enhancement request here: 1) A bug: when you look at the structure view for affected classes, there is a problem if you try to navigate from calls to advice (in AJDT, it results in an NPE). Here is the stack trace in AJDT: java.lang.NullPointerException at org.aspectj.asm.internal.ProgramElement.toLinkLabelString (ProgramElement.java:403) at org.eclipse.ajdt.internal.core.AJDTStructureViewNode.getLabel (AJDTStructureViewNode.java:171) at org.eclipse.ajdt.internal.core.AJDTStructureViewNodeAdapter.getLabel (AJDTStructureViewNodeAdapter.java:89) at org.eclipse.ui.model.WorkbenchLabelProvider.getText (WorkbenchLabelProvider.java:142) at org.eclipse.jface.viewers.TreeViewer.doUpdateItem(TreeViewer.java:95) at org.eclipse.jface.viewers.AbstractTreeViewer$UpdateItemSafeRunnable.run (AbstractTreeViewer.java:87) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1006) at org.eclipse.core.runtime.Platform.run(Platform.java:413) at org.eclipse.jface.viewers.AbstractTreeViewer.doUpdateItem (AbstractTreeViewer.java:406) at org.eclipse.jface.viewers.StructuredViewer$UpdateItemSafeRunnable.run (StructuredViewer.java:119) at org.eclipse.core.internal.runtime.InternalPlatform.run (InternalPlatform.java:1006) at org.eclipse.core.runtime.Platform.run(Platform.java:413) at org.eclipse.jface.viewers.StructuredViewer.updateItem (StructuredViewer.java:1271) at org.eclipse.jface.viewers.AbstractTreeViewer.createTreeItem (AbstractTreeViewer.java:320) at org.eclipse.jface.viewers.AbstractTreeViewer$1.run (AbstractTreeViewer.java:303) at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:69) at org.eclipse.jface.viewers.AbstractTreeViewer.createChildren (AbstractTreeViewer.java:289) at org.eclipse.jface.viewers.AbstractTreeViewer.handleTreeExpand (AbstractTreeViewer.java:697) at org.eclipse.jface.viewers.AbstractTreeViewer$4.treeExpanded (AbstractTreeViewer.java:709) at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:175) at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:81) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:840) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:865) at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:849) at org.eclipse.swt.widgets.Tree.wmNotifyChild(Tree.java:1909) at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:3815) at org.eclipse.swt.widgets.Composite.WM_NOTIFY(Composite.java:642) at org.eclipse.swt.widgets.Control.windowProc(Control.java:2816) at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361) at org.eclipse.swt.internal.win32.OS.CallWindowProcW(Native Method) at org.eclipse.swt.internal.win32.OS.CallWindowProc(OS.java:1236) at org.eclipse.swt.widgets.Tree.callWindowProc(Tree.java:156) at org.eclipse.swt.widgets.Tree.WM_LBUTTONDOWN(Tree.java:1517) at org.eclipse.swt.widgets.Control.windowProc(Control.java:2799) at org.eclipse.swt.widgets.Display.windowProc(Display.java:2361) at org.eclipse.swt.internal.win32.OS.DispatchMessageW(Native Method) at org.eclipse.swt.internal.win32.OS.DispatchMessage(OS.java:1303) at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:1543) at org.eclipse.ui.internal.Workbench.runEventLoop(Workbench.java:1402) at org.eclipse.ui.internal.Workbench.run(Workbench.java:1385) at org.eclipse.core.internal.boot.InternalBootLoader.run (InternalBootLoader.java:858) at org.eclipse.core.boot.BootLoader.run(BootLoader.java:461) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source) at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source) at java.lang.reflect.Method.invoke(Unknown Source) at org.eclipse.core.launcher.Main.basicRun(Main.java:291) at org.eclipse.core.launcher.Main.run(Main.java:747) at org.eclipse.core.launcher.Main.main(Main.java:583) 2) The enhancement request: the concrete aspect that applies the advice should also show what is affected in the project. Of course, it would also be nice to see how a given concrete library aspect in the aspect path affects your project too.</description></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/internal/ProgramElement.java</file></fixedFiles></bug><bug commit="5357086" fixdate="1063960000" id="43033" opendate="1063390000" status="resolved fixed"><buginformation><summary>43033 Compiler crash in ajc head (post 1.1.1 rc1) on erroneous program</summary><description /></buginformation><fixedFiles><file>tests/bugs/concretizeNpe/base/ExceptionHandling.java</file><file>tests/bugs/concretizeNpe/model/ModelExceptionHandling.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file></fixedFiles></bug><bug commit="fc0d2af" fixdate="1063910000" id="43194" opendate="1063770000" status="resolved fixed"><buginformation><summary>43194 java.lang.VerifyError in generated code</summary><description>See the attached file VerifyBug.jar for the source files. You won't need anything else to compiler and reproduce this bug: ~/bug&gt; ls AbstractCaching.java TreeNode.java VerifyBug.jar ContainerCaching.java TreeNodeFolding.java WorkspaceGroup.java ContainerLoader.java TreePanel.java WorkspaceNode.java Makefile TreeWorkspace.java ~/bug&gt; gmake /cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1 \lib\aspectjrt.jar" -version AspectJ Compiler 1.1.1 /cygdrive/c/aspectj1.1.1/bin/ajc -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar" *.java java -classpath "C:\aspectj1.1.1\lib\aspectjrt.jar;." TreeNode java.lang.VerifyError: (class: TreeNode, method: doShowAction signature: ()V) Unable to pop operand off an empty stack Exception in thread "main" make: *** [all] Error 1</description></buginformation><fixedFiles><file>tests/bugs/AdviceInteraction.java</file><file>weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java</file></fixedFiles></bug><bug commit="b512738" fixdate="1063390000" id="42993" opendate="1063360000" status="resolved fixed"><buginformation><summary>42993 Language regression, or possible language improvement?</summary><description>The file AspectBug.java: public aspect AspectBug extends AbstractCaching perthis(execution(ContainerLoader+.new(..))) { declare parents: ContainerDescriptor implements AbstractCaching.Key; protected pointcut loadExecutions( Key key ): ContainerLoader.containerLoads( *, key ); } abstract aspect AbstractCaching { interface Key {} protected abstract pointcut loadExecutions(Key key); } class Key { } class ContainerDescriptor { } class ActiveContainer { } class ContainerLoader { public ActiveContainer createContainer(ContainerDescriptor c) { return null; } public pointcut containerLoads(ContainerLoader loader, ContainerDescriptor containerDesc ): this(loader) &amp;&amp; args(containerDesc) &amp;&amp; execution(ActiveContainer ContainerLoader.createContainer (ContainerDescriptor)); } First, here are the versions of AspectJ I'm using (this is a bash shell under cygwin on Windows XP): ~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc - version ajc version 1.0.6 (built Jul 24, 2002 6:21 PM PST) running on java 1.4.1_02 ~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc - version AspectJ Compiler 1.1.0 ~&gt; CLASSPATH='C:\aspectj1.1.1rc1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc -version AspectJ Compiler 1.1.1rc1 ~&gt; CLASSPATH='C:\aspectj1.1.1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc -version AspectJ Compiler 1.1.1 For all four of these compilers, I give them the AspectBug.java file (which is attached): ~&gt; CLASSPATH='C:\aspectj1.0\lib\aspectjrt.jar' /cygdrive/c/aspectj1.0/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1\lib\aspectjrt.jar' /cygdrive/c/aspectj1.1/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1.1rc1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1rc1/bin/ajc AspectBug.java ~&gt; CLASSPATH='C:\aspectj1.1.1 \lib\aspectjrt.jar' /cygdrive/c/aspectj1.1.1/bin/ajc AspectBug.java C:\Documents and Settings\Macneil Shonle\AspectBug.java:7 incompatible type, expected ContainerDescriptor found BindingTypePattern(AbstractCaching$Key, 0) 1 error As you can see, only the final run (with the Sept 11 build of ajc) do we see the "incompatible type" error. If this is not a regression but a desirable result, how should the code be ported?</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file><file>tests/bugs/ParentsAndPointcuts.java</file><file>weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file></fixedFiles></bug><bug commit="8660cc1" fixdate="1062690000" id="42539" opendate="1062690000" status="resolved fixed"><buginformation><summary>42539 throw derivative pointcuts not advised.</summary><description>Given the following point cut and advice: public aspect ExceptionAspect { pointcut exceptionThrower() : execution(public * ExceptionBugTest.*(..) throws Exception+); declare warning : exceptionThrower() : "throws Exception+"; } And the to be aspected code: public class ExceptionBugTest { class MyException extends Exception { } public void method1() throws Exception { } public void method2() throws MyException { } } listing file default.lst: C:\temp\AJC Bug\ExceptionAspect.aj C:\temp\AJC Bug\ExceptionBugTest.java AJC does not advise ExceptionBugTest.method2(). The output from the compilation is the following: C:\temp\AJC Bug&gt;ajc -argfile default.lst -classpath %ASPECTJ_HOME%\lib\aspectjrt.jar C:\eclipse\workspace\AJC Bug\ExceptionBugTest.java:11 throws Exception+ From the aspect-j mailing list, contributed by Jim Hugunin: &lt;detail&gt;The bug was caused because the code for ThrowsPattern mistakenly used the internal protected method TypePattern.matchesExactly instead of the external public method TypePattern.matchesStatically. Because the classes were in the same package, Java's accessibility rules allowed this. It would be nice if there was an easy way to specifiy that a method could only be accessed from subtypes.&lt;/detail&gt;</description></buginformation><fixedFiles><file>tests/bugs/throwsSignature/ExceptionAspect.java</file><file>tests/bugs/throwsSignature/ExceptionBugTest.java</file><file>weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java</file></fixedFiles></bug><bug commit="d90acdc" fixdate="1061480000" id="39436" opendate="1056740000" status="verified fixed"><buginformation><summary>39436 [Tasks] No summary shown in status line</summary><description>build I20030625 The old tasks view showed a summary of the number of tasks, errors, warnings and infos in the status line. This is missing in the reworked view.</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file></fixedFiles></bug><bug commit="3e59745" fixdate="1060310000" id="41123" opendate="1060060000" status="resolved fixed"><buginformation><summary>41123 Weaving failure when using injars</summary><description>Sample run that fails using injars: C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj C:\devel\test\libraryWeave&gt;jar cf ajee.jar ajee\testing\*.class C:\devel\test\libraryWeave&gt;ajc -injars ajee.jar model\BusObj.java model\MonitorB usObj.java C:\devel\test\libraryWeave\model\BusObj.java:3 Class must implement the inherite d abstract method ExecutionMonitor.MonitoredItem.ajc$interMethodDispatch2 $ajee_t esting_ExecutionMonitor$record(String, String) public class BusObj { ^^^^^^ 1 error It works in a single pass compilation: C:\devel\test\libraryWeave&gt;ajc ajee\testing\ExecutionMonitor.aj model\BusObj.jav a model\MonitorBusObj.java C:\devel\test\libraryWeave&gt; Sample source code: package ajee.testing; public aspect ExecutionMonitor { public interface MonitoredItem {} private void MonitoredItem.record(String eventType, String eventName) {} } --- package model; public class BusObj { } --- package model; import ajee.testing.ExecutionMonitor; public aspect MonitorBusObj { declare parents: BusObj implements ExecutionMonitor.MonitoredItem; }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java</file><file>tests/bugs/moreInterfaceLibrary/model/BusObj.java</file><file>tests/bugs/moreInterfaceLibrary/model/MonitorBusObj.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file></fixedFiles></bug><bug commit="acdf688" fixdate="1060240000" id="40257" opendate="1058380000" status="resolved fixed"><buginformation><summary>40257 parsing of "../" paths in LST files is broken</summary><description>Relative paths (e.g. "../") are no longer parser properly in AJDE 1.1.0.</description></buginformation><fixedFiles><file>ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.java</file><file>ajbrowser/testsrc/org/aspectj/tools/ajbrowser/InteractiveBrowserTest.java</file><file>ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java</file><file>org.aspectj.ajdt.core/testdata/bug-40257/d1/A.java</file><file>org.aspectj.ajdt.core/testdata/bug-40257/d1/d2/B.java</file><file>org.aspectj.ajdt.core/testdata/bug-40257/d3/C.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java</file></fixedFiles></bug><bug commit="7886970" fixdate="1059560000" id="39626" opendate="1057310000" status="resolved fixed"><buginformation><summary>39626 Compiler error when compiling a buggy class</summary><description>I use AspectJ 1.1 from within eclipse. After some time of developing, I get following stack trace (Wrapped in the eclipse gui), when I try to compile a java file with a huge amount of syntax errors, missing variables, and other problems. As soon as I have fixed these issues, I can comnpile normally as ever. Unfortunatly I can not provide any more detailed information because: this errors pops up randomly, disappears when the bug is fixed, I have neither the time nor the permission to create a more accurate sample java.lang.NullPointerException at java.lang.String.&lt;init&gt;(String.java:214) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit (AsmBuilder.java:231) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.visit (AsmBuilder.java:259) at org.eclipse.jdt.internal.compiler.ast.AnonymousLocalTypeDeclaration.traverse (AnonymousLocalTypeDeclaration.java:138) at org.eclipse.jdt.internal.compiler.ast.QualifiedAllocationExpression.traverse (QualifiedAllocationExpression.java:342) at org.eclipse.jdt.internal.compiler.ast.MessageSend.traverse (MessageSend.java:299) at org.eclipse.jdt.internal.compiler.ast.Block.traverse(Block.java:147) at org.eclipse.jdt.internal.compiler.ast.ForStatement.traverse (ForStatement.java:347) at org.eclipse.jdt.internal.compiler.ast.MethodDeclaration.traverse (MethodDeclaration.java:157) at org.eclipse.jdt.internal.compiler.ast.TypeDeclaration.traverse (TypeDeclaration.java:946) at org.eclipse.jdt.internal.compiler.ast.CompilationUnitDeclaration.traverse (CompilationUnitDeclaration.java:303) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.internalBuild (AsmBuilder.java:169) at org.aspectj.ajdt.internal.core.builder.AsmBuilder.build (AsmBuilder.java:66) at org.aspectj.ajdt.internal.compiler.lookup.EclipseFactory.finishedCompilationUnit (EclipseFactory.java:303) at org.aspectj.ajdt.internal.compiler.AjCompiler.process(AjCompiler.java:67) at org.eclipse.jdt.internal.compiler.Compiler.compile(Compiler.java:338) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.performCompilation (AjBuildManager.java:372) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.doBuild (AjBuildManager.java:133) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:78) at org.aspectj.ajde.internal.CompilerAdapter.compile (CompilerAdapter.java:117) at org.aspectj.ajde.internal.AspectJBuildManager$CompilerThread.run (AspectJBuildManager.java:164) LoadTest.java CrefoClient/src/com/dcbank/scoring/socketserver kind regards Arno Schmidmeier</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java</file></fixedFiles></bug><bug commit="d5ea336" fixdate="1058980000" id="40380" opendate="1058450000" status="resolved fixed"><buginformation><summary>40380 AspectJ does not honour libraries defined via Project Properties</summary><description>AJDT 1.1.3, Eclipse 2.1 To build a JDK 1.4. program under Eclipse using JDK 1.3 the appropriate build library should be selected in the Project Properties "Java Build Path". However AspectJ continues to use the JDK associated with Eclipse so errors result from using 1.4 APIs. The same will occur running Eclipse under 1.4 and compiling programs for 1.5 Testcase: 1. Run Eclipse under JDK 1.3 2. Create a Java project which uses a 1.4 JDK 3. Write a Java classes that uses 1.4 APIs e.g. public class TestStringBuffer { public static void main(String[] args) { new StringBuffer("Test").indexOf("T"); } } 4. Convert to AspectJ project</description></buginformation><fixedFiles><file>ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file></fixedFiles></bug><bug commit="026b272" fixdate="1058910000" id="39993" opendate="1058120000" status="resolved fixed"><buginformation><summary>39993 ajc stack trace on declaring hashcode() method in aspect</summary><description>From an email sent to the user's list 6/26/2003: ------------------------------------------ ajc 1.1 NPE when an aspect declares hashcode() as follows: interface Identifiable { void setId(Id id); Id getId(); } aspect IdentifiableAspect { private Id Identifiable.id = null; public Id Identifiable.getId() { return this.id; } public void Identifiable.setId(Id id) { this.id = id; } public int Identifiable.hashCode() { return (this.getId() == null) ? super.hashCode() : this.getId().hashCode(); } } A workaround for callers the compiler controls is to replace the declaration with around advice: int around(Identifiable i): target(i) &amp;&amp; call(public int hashCode()) { return (i.getId() == null) ? proceed(i) : i.getId().hashCode(); }</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java</file><file>tests/bugs/MultipleSuperCf.java</file><file>tests/bugs/OverridingInterfaceObjectMethod.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java</file></fixedFiles></bug><bug commit="c509c6f" fixdate="1054060000" id="38131" opendate="1054010000" status="resolved fixed"><buginformation><summary>38131 ajc needs -d . option while correctly compiling classes from subpackage</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/testdata/src1/WrongPackage.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java</file></fixedFiles></bug><bug commit="2072ac1" fixdate="1053370000" id="37739" opendate="1053050000" status="resolved fixed"><buginformation><summary>37739 Unexpected Xlint:unresolvableMember warning with withincode</summary><description>The following code produces an Xlint:unresolvableMember warning: class A { A(Class type) {} A() { this(String.class); } } class B { public void test() { } public void test2() { test(); } } aspect C { void around() : (call (void B.test()) &amp;&amp; withincode (void B.test2())) { proceed(); } } The warning text is: Warning.java:22 can not resolve this member: void A.&lt;catch&gt;(java.lang.ClassNotFoundException) [Xlint:unresolvableMember] Line 22 is the line in the aspect that says "withincode". If I comment out the aspect, the warning goes away. Also, if I comment out A's default constructor, it goes away. The "String.class" seems to have something to do with the warning. I can reproduce this with 1.1rc1 and 1.1rc2.</description></buginformation><fixedFiles><file>tests/bugs/CatchSig.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="f236927" fixdate="1051490000" id="34951" opendate="1047580000" status="resolved fixed"><buginformation><summary>34951 NPE compiling without aspectjrt.jar</summary><description>Compiling spacewar without specifying aspectjrt.jar on the classpath causes a NPE. Expected an error message "aspectjrt.jar required". Steps to reproduce 1) install latest 2) cd doc/examples 3) java -jar ../../lib/aspectjtools.jar -verbose @spacewar/debug.lst RESULT:NPE in attached log</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java</file></fixedFiles></bug><bug commit="1e502f5" fixdate="1051290000" id="36803" opendate="1051120000" status="resolved fixed"><buginformation><summary>36803 BCException thrown by AspectJ 1.1rc1</summary><description>[iajc] expected state: resolved got: concrete [iajc] expected state: resolved got: concrete [iajc] org.aspectj.weaver.BCException: expected state: resolved got: concrete [iajc] at org.aspectj.weaver.patterns.Pointcut.assertState (Pointcut.java:236) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:126) [iajc] at org.aspectj.weaver.patterns.CflowPointcut.concretize1 (CflowPointcut.java:143) [iajc] at org.aspectj.weaver.patterns.NotPointcut.concretize1 (NotPointcut.java:94) [iajc] at org.aspectj.weaver.patterns.AndPointcut.concretize1 (AndPointcut.java:88) [iajc] at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePointcut.java:270) [iajc] at org.aspectj.weaver.patterns.AndPointcut.concretize1 (AndPointcut.java:88) [iajc] at org.aspectj.weaver.patterns.ReferencePointcut.concretize1 (ReferencePointcut.java:270) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:127) [iajc] at org.aspectj.weaver.patterns.Pointcut.concretize (Pointcut.java:120) [iajc] at org.aspectj.weaver.Advice.concretize(Advice.java:207) [iajc] at org.aspectj.weaver.CrosscuttingMembers.addShadowMunger (CrosscuttingMembers.java:78) [iajc] at org.aspectj.weaver.CrosscuttingMembers.addShadowMungers (CrosscuttingMembers.java:72) [iajc] at org.aspectj.weaver.ResolvedTypeX.collectCrosscuttingMembers (ResolvedTypeX.java:328) [iajc] at org.aspectj.weaver.CrosscuttingMembersSet.addOrReplaceAspect (CrosscuttingMembersSet.java:54) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.prepareForWeave (BcelWeaver.java:164) [iajc] at org.aspectj.weaver.bcel.BcelWeaver.weave (BcelWeaver.java:214) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFile s(AjBuildManager.java:394) [iajc] at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (AjBuildManager.java:149) [iajc] at org.aspectj.ajdt.ajc.AjdtCommand.runCommand (AjdtCommand.java:55) [iajc] at org.aspectj.tools.ajc.Main.run(Main.java:216) [iajc] at org.aspectj.tools.ajc.Main.runMain(Main.java:155) [iajc] at org.aspectj.tools.ant.taskdefs.AjcTask.execute (AjcTask.java:646) [iajc] at org.apache.tools.ant.UnknownElement.execute (UnknownElement.java:193) [iajc] at org.apache.tools.ant.Task.perform(Task.java:341) [iajc] at org.apache.tools.ant.Target.execute(Target.java:309) [iajc] at org.apache.tools.ant.Target.performTasks(Target.java:336) [iajc] at org.apache.tools.ant.Project.executeTarget (Project.java:1339) [iajc] at org.apache.tools.ant.Project.executeTargets (Project.java:1255) [iajc] at org.apache.tools.ant.Main.runBuild(Main.java:609) [iajc] at org.apache.tools.ant.Main.start(Main.java:196) [iajc] at org.apache.tools.ant.Main.main(Main.java:235)</description></buginformation><fixedFiles><file>tests/bugs/CflowConcrete.java</file><file>weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/Pointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java</file></fixedFiles></bug><bug commit="56cc4f2" fixdate="1047580000" id="34925" opendate="1047570000" status="resolved fixed"><buginformation><summary>34925 compiler crash on yesterday's rc1 build</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java</file><file>tests/bugs/ConvertToUnchecked.java</file></fixedFiles></bug><bug commit="7746fcb" fixdate="1047510000" id="34858" opendate="1047500000" status="resolved fixed"><buginformation><summary>34858 Weaver crash</summary><description /></buginformation><fixedFiles><file>tests/bugs/CflowBinding.java</file><file>tests/bugs/CflowBindingOrig.java</file><file>weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java</file></fixedFiles></bug><bug commit="0fb5f69" fixdate="1047430000" id="29934" opendate="1043200000" status="resolved fixed"><buginformation><summary>29934 runtime NullPointerException when applying around advice to other around advice</summary><description>When the program below is run, it produces a NullPointerException... java.lang.NullPointerException at A2.ajc$around$A2$3b6proceed(CflowCycles.java) at A2.ajc$around$A2$3b6_aroundBody3(CflowCycles.java:35) at Target.run(CflowCycles.java:24) at CflowCycles.run_aroundBody4(CflowCycles.java:8) at CflowCycles.main_aroundBody6(CflowCycles.java:24) at CflowCycles.main(CflowCycles.java:24) ---(in new/CflowCycles.java and in ajcTestsFailing.xml) import org.aspectj.testing.Tester; /** @testcase cflow cycles in advice from different aspects */ public class CflowCycles { public static void main( String args[] ) { Tester.expectEvent("target A1"); Tester.expectEvent("target A2"); new Target().run(); Tester.checkAllEventsIgnoreDups(); } } class Target { public void run(){ } } aspect A1 { pointcut TargetRunFlow () // ok if no cflow: within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within (A1+); : !within(A1+) &amp;&amp; !preinitialization(new(..)) &amp;&amp; !initialization(new (..))//cflow(within(Target) &amp;&amp; execution(* *(..))) &amp;&amp; !within(A1+) ; Object around () : TargetRunFlow() { Tester.event("target A1"); return proceed(); } // ok if in the same class } aspect A2 { pointcut TargetRun () : within(Target) &amp;&amp; execution(* *(..)) &amp;&amp; !within(A2+); ; Object around () : TargetRun() { Tester.event("target A2"); return proceed(); } }</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/BcelShadow.java</file></fixedFiles></bug><bug commit="d1e5c0a" fixdate="1046910000" id="32463" opendate="1045830000" status="resolved fixed"><buginformation><summary>32463 ajc reports error when encountering static declaration of nested classes</summary><description>Version: AspectJ Compiler 1.1beta4 The ajc compiler issues a spurious error message and exits with a negative error code when weaving code containing static declaration of a nested class. The compiler seem to write the classfiles correctly but the negative exit status causes problems when e.g. using the AjcCompilerAdapter in ant. To reproduce: 1) Extract the following two files into an empty directory: // File: A.aj: aspect A { pointcut withinTest(): within(Test); pointcut callToHandleOrder() : (withinTest() &amp;&amp; call(* handleOrder(..))); Object around(): callToHandleOrder() { return "DUMMY inserted by ASPECT" ; } } // End of File A.aj // File : Test.java public class Test { // Commenting out the static declaration makes everything work OK static { class StaticNestedClass { } } public static void main(String[] args) { System.out.println(new Test().handleOrder("test")); } private String handleOrder(String t) { return t; } } // End of Test.java 2) Compile the files ajc -sourceroots . -verbose Output: ----- compiling c:/aspectj1.1/doc/examples/bug/./A.aj compiling c:/aspectj1.1/doc/examples/bug/./Test.java weaving might need to weave [UnwovenClassFile(null, Test$1$StaticNestedClass), UnwovenClassFile(null, A), UnwovenClassFile(null, Test)](world=true) wrote class file: c:\aspectj1.1\doc\examples\bug\A.class can't find type Test$1 wrote class file: c:\aspectj1.1\doc\examples\bug\Test$1$StaticNestedClass.class wrote class file: c:\aspectj1.1\doc\examples\bug\Test.class 1 error ------</description></buginformation><fixedFiles><file>tests/bugs/WeaveLocal.java</file><file>weaver/src/org/aspectj/weaver/NameMangler.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/TypeX.java</file><file>weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java</file><file>weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java</file></fixedFiles></bug><bug commit="cb77524" fixdate="1046900000" id="33635" opendate="1046650000" status="resolved fixed"><buginformation><summary>33635 Negation of if pointcut does not work</summary><description /></buginformation><fixedFiles><file>tests/bugs/NotIf.java</file><file>weaver/src/org/aspectj/weaver/patterns/IfPointcut.java</file></fixedFiles></bug><bug commit="19c3e16" fixdate="1045180000" id="31423" opendate="1044810000" status="resolved fixed"><buginformation><summary>31423 Pointcut adviceexecution() does not work</summary><description>Pointcut adviceexecution() does not seem to pick advice execution join points in beta4. Here is a program that shows the problem: public class Test { public static void main(String[] args) { } } aspect Aspect1 { before() : execution(* Test.*(..)) { System.out.println("Reached " + thisJoinPoint); } } aspect Aspect2 { before() : adviceexecution() &amp;&amp; !within(Aspect2) { System.out.println("Reached " + thisJoinPoint); } } F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc -version AspectJ Compiler 1.1beta4 F:\aop\bugs\1.1\b4\adviceexecution&gt;ajc Test.java F:\aop\bugs\1.1\b4\adviceexecution&gt;java Test Reached execution(void Test.main(String[]))</description></buginformation><fixedFiles><file>tests/bugs/AdviceExec.java</file><file>weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java</file><file>weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java</file></fixedFiles></bug><bug commit="d15eb32" fixdate="1045170000" id="30168" opendate="1043410000" status="resolved fixed"><buginformation><summary>30168 Error with certain combination of advice</summary><description /></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java</file><file>tests/bugs/crashes/test/Test3.java</file></fixedFiles></bug><bug commit="3e2801a" fixdate="1045170000" id="29959" opendate="1043240000" status="resolved fixed"><buginformation><summary>29959 super call in intertype method declaration body causes VerifyError</summary><description>AspectJ Compiler 1.1beta4 This program: aspect Foo { void A.foo() { } void B.foo() { super.foo(); } } class A { } class B extends A { } class Main { public static void main(String[] args) { new B(); } } causes this error at runtime: Exception in thread "main" java.lang.VerifyError: (class: B, method: ajc$superDispatch$B$foo signature: ()V) Illegal use of nonvirtual function call at Main.main(Foo.java:11) Note that foo is never even called; the error happens at load time when the new B() expression causes class B to be loaded. There's no error if either one of the foo methods is declared in its class directly. This is kind of a showstopper... --Doug</description></buginformation><fixedFiles><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java</file><file>org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java</file><file>org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java</file><file>org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java</file><file>org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java</file><file>tests/bugs/SuperToIntro.java</file></fixedFiles></bug><bug commit="85a827a" fixdate="1043460000" id="29769" opendate="1042990000" status="resolved fixed"><buginformation><summary>29769 Ajde does not support new AspectJ 1.1 compiler options</summary><description>The org.aspectj.ajde.BuildOptionsAdapter interface does not yet support the new AspectJ 1.1 compiler options. These need to be added to the interface, any old or renamed options deprecated, and then the correct processing needs to happen within Ajde to pass these options to the compiler. This enhancement is needed by the various IDE projects for there AspectJ 1.1 support.</description></buginformation><fixedFiles><file>ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java</file><file>ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java</file><file>ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java</file><file>ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java</file><file>ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java</file><file>ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java</file><file>ajde/testdata/examples/figures-coverage/figures/Figure.java</file><file>ajde/testsrc/org/aspectj/ajde/AjdeTests.java</file><file>ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java</file><file>ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java</file><file>ajde/testsrc/org/aspectj/ajde/NullIdeManager.java</file><file>ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java</file><file>ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java</file><file>ajde/testsrc/org/aspectj/ajde/StructureModelTest.java</file><file>ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java</file><file>org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java</file></fixedFiles></bug><bug commit="c1260e6" fixdate="1042580000" id="29186" opendate="1042080000" status="resolved fixed"><buginformation><summary>29186 ajc -emacssym chokes on pointcut that includes an intertype method</summary><description /></buginformation><fixedFiles><file>asm/src/org/aspectj/asm/StructureModel.java</file><file>org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java</file><file>weaver/src/org/aspectj/weaver/AsmAdaptor.java</file><file>weaver/src/org/aspectj/weaver/Lint.java</file><file>weaver/src/org/aspectj/weaver/ResolvedTypeX.java</file><file>weaver/src/org/aspectj/weaver/Shadow.java</file><file>weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java</file></fixedFiles></bug><bug commit="2781720" fixdate="1042570000" id="28919" opendate="1041280000" status="resolved fixed"><buginformation><summary>28919 waever tries to weave into native methods ...</summary><description>If you don't find the exception below in a bug, please add a new bug To make the bug a priority, please include a test program that can reproduce this exception. bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl java.lang.RuntimeException: bad non-abstract method with no code: private native int nativeMessagePumpInitialize() on public class plc.comm.pvi.PviCom$LinkEventHandlerImpl at org.aspectj.weaver.bcel.LazyMethodGen.&lt;init&gt;(Unknown Source) at org.aspectj.weaver.bcel.LazyClassGen.&lt;init&gt;(Unknown Source) at org.aspectj.weaver.bcel.BcelObjectType.getLazyClassGen(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.weaver.bcel.BcelWeaver.weave(Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.weaveAndGenerateClassFiles (Unknown Source) at org.aspectj.ajdt.internal.core.builder.AjBuildManager.batchBuild (Unknown Source) at org.aspectj.ajdt.ajc.AjdtCommand.runCommand(Unknown Source) at org.aspectj.tools.ajc.Main.run(Unknown Source) at org.aspectj.tools.ajc.Main.runMain(Unknown Source) at org.aspectj.tools.ajc.Main.main(Unknown Source)</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java</file></fixedFiles></bug><bug commit="99a873c" fixdate="1042570000" id="28974" opendate="1041610000" status="resolved fixed"><buginformation><summary>28974 Compiler error when introducing a "final" field</summary><description>The aspect below fails to compile with 1.1b2, producing the compilation error: -------------------- $ ajc com/ibm/amc/*.java com/ibm/amc/ejb/*.java d:/eclipse/runtime-workspace-ajsamples/Mock EJBs/com/ibm/amc/DemoBeanEJB.java:1: Cannot assign a value to the final field com.ibm.amc.DemoBean.ajc$interField$co m_ibm_amc$verbose !! no source information available !! 1 error --------------------------- package com.ibm.amc; import com.ibm.amc.ejb.SessionBean; /** * @author colyer * * To change this generated comment edit the template variable "typecomment": * Window&gt;Preferences&gt;Java&gt;Templates. * To enable and disable the creation of type comments go to * Window&gt;Preferences&gt;Java&gt;Code Generation. */ public aspect DemoBeanEJB { declare parents: DemoBean implements SessionBean; // THIS NEXT LINE IS THE CULPRIT static final boolean DemoBean.verbose = true; private transient String DemoBean.ctx; public void DemoBean.ejbActivate( ) { if ( verbose ) { System.out.println( "ejbActivate Called" ); } } } ------------------- Making the inter-type declaration non-final solves the problem...</description></buginformation><fixedFiles><file>weaver/src/org/aspectj/weaver/AjcMemberMaker.java</file></fixedFiles></bug></bugrepository>